---
title: 代码随想录刷题笔记（持续更新...） 
date: 2022-2-28
tags: 
- 代码随想录
categories:
- Algorithm
sticky: 1
---

## 数组

### 1. 二分查找

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

```java
//适用于target定义在左闭右闭的区间，即[left,right]
class Solution {
    public int search(int[] nums, int target) {
        int left =0;
        int right = nums.length-1;
        int middle;
        //如果target不在数组内部，提前做判断返回，减少后面的循环次数
        if(target<nums[0]||target>nums[nums.length-1]){
            return -1;
        }
        //注意是left<=right
        while(left<=right){
            middle = left+(right-left)/2;
            if(target==nums[middle]){
                return middle;
            }else if(target<nums[middle]){
                //如果写成right=middle，还可以进一步优化，因为target一定不等于nums[middle]，所以right=middle-1
                right=middle-1;
            }else{
                left=middle+1;
            }
        }
        return -1;
    }
}
//适用于target定义在左闭右开的区间，即[left,right)
class Solution {
    public int search(int[] nums, int target) {
        int left = 0, right = nums.length;
        //注意是left<right
        while (left < right) {
            int mid = left + ((right - left) >> 1);
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] < target)
                left = mid + 1;
            else if (nums[mid] > target)
                //注意是r
                right = mid;
        }
        return -1;
    }
}
```

### 2. 移除元素

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

```java
//暴力解法
class Solution {
    public int removeElement(int[] nums, int val) {
        int length = nums.length;
        for(int i=0;i<length;i++){     
            if(val==nums[i]){
                for(int j=i+1;j<length;j++){
                    nums[j-1]=nums[j];
                }
                i--;
                length--;
            }
        }
        return length;
    }
}
//双指针
class Solution {
    public int removeElement(int[] nums, int val) {
        int fast=0;
        int slow;
        for(slow=0;fast<nums.length;fast++){
            if(nums[fast]!=val){
                nums[slow]=nums[fast];
                slow++;
            }
        }
        return slow;
    }
}
```

### 3. 有序数组的平方

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

```java
class Solution {
    //双指针解法
    public int[] sortedSquares(int[] nums) {
        int left = 0;
        int right =nums.length-1;
        int[] res = new int[nums.length];
        int p = res.length-1;
        while(left<=right){
            if(nums[left]*nums[left]>nums[right]*nums[right]){
                res[p--]=nums[left]*nums[left];
                left++;
            }else{
                res[p--]=nums[right]*nums[right];
                right--;
            }
        }
        return res;
    }
}
时间复杂度：O(n)
空间复杂度：O(1)（不算存储数组z）或者O(n)都没问题
```

### 4. 长度最小的子数组

给定一个含有 n 个正整数的数组和一个正整数 target 。找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

```java
//滑动窗口
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        //滑动窗口和双指针类似
        //左指针
        int l=0;
        //初始化返回的结果
        int res = Integer.MAX_VALUE;
        //sum用于计算滑动窗口元素的和
        int sum=0;
        for(int r=0;r<nums.length;r++){
            sum+=nums[r];
            //判断滑动窗口的值是否大于target
            while(sum>=target){
                //计算符合条件的最小的滑动窗口大小
                res=Math.min(r-l+1,res);
                //左指针右移，缩小滑动窗口
                sum-=nums[l++];
            }
        }
        return res==Integer.MAX_VALUE?0:res;
    }
}

//暴力解法
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int res=0;
        int min=Integer.MAX_VALUE;
        Set<Integer> set = new HashSet<>();
        for(int i=0;i<nums.length;i++){
            res=nums[i];
            for(int j=i+1;j<nums.length;j++){
                if(res>=target){
                    return 1;
                }
                res+=nums[j];
                if(res>=target){
                    set.add(j-i+1);
                    break;
                }
            }  
        }
        if(nums[nums.length-1]==target){
            set.add(1);
        }
        if(set.isEmpty()){
            return 0;
        }
        for(Integer e:set){
            min=Math.min(e,min);
        }
        return min;
    }
}
```

### 5. 螺旋矩阵Ⅱ

给你一个正整数 n ，生成一个包含 1 到 n² 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。

![螺旋矩阵Ⅱ-2022-04-19-21-27-40](https://imagecontainter-1309978559.cos.ap-chengdu.myqcloud.com/blogimages/螺旋矩阵Ⅱ-2022-04-19-21-27-40.png)

![test-2022-04-19-21-47-23](www.yhli.work/blogimages/test-2022-04-19-21-47-23.png)

```java
    public stati int[][] generateMatrix(int n) {
        if(n==1) return new int[][]{{1}};
        int[][] res = new int[n][n];
        int l=0;
        int r=n-1;
        int t=0;
        int b=n-1;
        //count用来计数
        int count =1;
        int mid = n/2;
        while(true){
            //1.模拟从左向右
            for(int i=t;i<r;i++){
                res[t][i]=count++;
            }
            //上边界向内缩进一格
            if(++t>b) break;
            //2.模拟从上到下
            for(int i=l;i<b;i++){
                res[i][r]=count++;
            }
            //右边界向内缩进一格
            if(--r<l) break;
            //3.模拟从右到左
            for(int i= r+1;i>l;i--){
                res[b][i]=count++;
            }
            //下边界向内缩进一格
            //if(--b<t) break;当n=2时会出错
            if(b--<t) break;
            //4.模拟从下到上
            for(int i=b+1;i>=t;i--){
                res[i][l]=count++;
            }
            //左边界向内缩进一格
            if(++l>r) break;
        }
        if(n%2==1){
            //n为奇数，上面while中的算法会导致矩阵中心为0，因此需要手动给矩阵中心赋值
            res[mid][mid]=count;
        }
        return res;
    }
```

## 链表

### 203. 移除链表元素

给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回新的头节点 。

```java
public class ListNode{
    int val;
    ListNode next;
    ListNose(){}
    ListNode(int val){this.val=val;}
    ListNode(int val,ListNode next){this.val=val;this.next=next;}
}
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode dummy = new ListNode(0,head);
        //关键：初始时pre和dummy管理的是同一个结点
        ListNode pre = dummy;
        ListNode cur = head;
        while(cur!=null){
            if(cur.val==val){
                pre.next=cur.next;
            }else{
                pre=cur;
            }
            cur=cur.next;
        }
        return dummy.next;
    }
}
```

### 707. 设计链表的实现

您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。在链表类中实现这些功能：
get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。
addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。
addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。
addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。
deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。

```java
//自己定义一个单链表类
class ListNode{
    int val;
    ListNode next;
    ListNode(){};
    ListNode(int val){
        this.val=val;
    }
    ListNode(int val,ListNode next){
        this.val=val;
        this.next=next;
    }
}
class MyLinkedList {
    //size存储链表元素个数
    int size;
    ListNode head;
    //初始化链表
    public MyLinkedList() {
        size=0;
        head=new ListNode(0);
    }
    
    public int get(int index) {
        if(index<0||index>=size){
            return -1;
        }
        ListNode cur = head;
        for(int i=0;i<=index;i++){
            cur=cur.next;
        }
        return cur.val;
    }
    
    public void addAtHead(int val) {
        addAtIndex(0,val);
    }
    
    public void addAtTail(int val) {
        addAtIndex(size,val);
    }
 
    public void addAtIndex(int index, int val) {
        //index大于链表的长度
        if(index>size){
            return;
        }
        //index小于0
        if(index<0){
            index=0;
        }
        size++;
        //0=<index长度<=链表长度
        //找到要插入结点的前驱结点
        ListNode pre = head;
        for(int i=0;i<index;i++){
            pre=pre.next;
        }
        ListNode toAdd = new ListNode(val);
        toAdd.next = pre.next;
        pre.next=toAdd;
    }

    public void deleteAtIndex(int index) {
        //判断索引是否有效
        if(index<0||index>=size){
            return;
        }
        //找到要删除结点的前驱结点
        ListNode pre = head;
        for(int i=0;i<index;i++){
            pre=pre.next;
        }
        pre.next=pre.next.next;
        size--;
    }

}

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList obj = new MyLinkedList();
 * int param_1 = obj.get(index);
 * obj.addAtHead(val);
 * obj.addAtTail(val);
 * obj.addAtIndex(index,val);
 * obj.deleteAtIndex(index);
 */
```

### 206. 反转链表

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
         ListNode pre = null;
         ListNode temp =null;
         ListNode cur = head;
         while(cur!=null){
             temp=cur.next;
             cur.next=pre;
             pre=cur;
             cur=temp;
         }
         return pre;
    }
}
```

### 24. 两两交换链表中的结点

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummy = new ListNode(0,head);
        ListNode pre =dummy;
        while(pre.next!=null&&pre.next.next!=null){
            ListNode temp = head.next.next;
            pre.next=head.next;
            //注意理解head.next.next代表的含义
            head.next.next=head;
            head.next=temp;
            pre=head;
            head=head.next;
        }
        return dummy.next;
    }
}
```

### 19. 删除链表的倒数第N个结点

给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

```java
//思路：先求出链表的长度len，如果len=n,说明要删除的是头节点，此时需要创建一个辅助虚拟节点；其它情况是遍历找到要删除节点的前驱结点pre，然后pre.next=pre.next.next
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        int len =0;
        ListNode cur =head;
        ListNode dummy = new ListNode(0,head);
        while(head!=null){
            len++;
            head=head.next;
        }
        if(n==len){
            dummy.next=cur.next;
            return dummy.next;
        }
        for(int i=0;i<len-n-1;i++){
            cur=cur.next;
        }
        cur.next=cur.next.next;
        return dummy.next;
    }
}
//另一个思路，使用双指针，初始时slow和fast指针指向head头节点，然后将fast指针向前移动n个位置，最后同步移动slow和fast指针，fast指针指向null时，slow指针z
```

### 面试题02.07.链表相交

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。

```java
// public class ListNode{
//     int val;
//     ListNode next;
//     public ListNode(){}
//     public ListNode(int val){
//         this.val=val;
//     }
//     public ListNode(int val,ListNode next){
//         this.val=val;
//         this.next=next;
//     }
// }
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode curA = headA;
        ListNode curB = headB;
        int lenA=0;
        int lenB=0;
        //计算头节点为headA的链表的长度
        while(headA!=null){
            lenA++;
            headA=headA.next;
        }
         //计算头节点为headB的链表的长度
        while(headB!=null){
            lenB++;
            headB=headB.next;
        }
        if(lenA>=lenB){
            for(int i=0;i<lenA-lenB;i++){
                curA=curA.next;
            }
            while(curA!=curB){
                curB=curB.next;
                curA=curA.next;
            }
            return curA;
        }else{
            for(int i=0;i<lenB-lenA;i++){
                curB=curB.next;
            }
            while(curA!=curB){
                curB=curB.next;
                curA=curA.next;
            }
            return curA;
        }
    }
}
```

### 142. 环形链表Ⅱ

给定一个链表的头节点head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。不允许修改链表。

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        ListNode p1 = head;
        ListNode p2 =head;
        while(fast!=null&&fast.next!=null){
            fast=fast.next.next;
            slow=slow.next;
            if(fast==slow){
                p2=fast;
                while(p1!=p2){
                    p1=p1.next;
                    p2=p2.next;
                }
                return p1;
            }
        }
        return null;
    }
}
//备注：也可以采用哈希表，如果遇到重复的一定有h
```

## 哈希表

### 242. 有效的字母异位词

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。

```java
public class IsAnagram {
    public boolean isAnagram(String s, String t) {
        //k存的是字符，v存的是字符出现的次数
        Map<Character,Integer> maps = new HashMap<>();
        Map<Character,Integer> mapt = new HashMap<>();
        for(int i=0;i<s.length();i++){
            maps.put(s.charAt(i),maps.getOrDefault(s.charAt(i),0)+1);
        }
        for(int i=0;i<t.length();i++){
            mapt.put(t.charAt(i),mapt.getOrDefault(t.charAt(i),0)+1);
        }
        for(Character e:maps.keySet()){
            if(mapt.containsKey(e)){
                //if(maps.get(e)!=mapt.get(e))，会报错，包装器类之间的比较要用equals
                if(!maps.get(e).equals(mapt.get(e))){
                    return false;
                }
            }else{
                return false;
            }
        }
        return maps.size()!=mapt.size()?false:true;
    }
}
```

### 349. 两个数组的交集

给定两个数组 `nums1` 和 `nums2` ，返回 *它们的交集* 。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        Set<Integer> set1 = new HashSet<>();
        Set<Integer> resSet = new HashSet<>();
        for (int i : nums1) {
            set1.add(i);
        }
        for (int i : nums2) {
            if(set1.contains(i)){
                resSet.add(i);
            }
        }
        int[] res = new int[resSet.size()];
        int index = 0;
        for (Integer e : resSet) {
            //自动拆箱
            res[index++]=e;
        }
        return res;
    }
}
```

### 202. 快乐数

编写一个算法来判断一个数 n 是不是快乐数。「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果可以变为  1，那么这个数就是快乐数。如果 n 是快乐数就返回 True ；不是，则返回 False 。

```java
class Solution {
    
    public int sum(int n){
        int res=0;
        while(n!=0){
            int mod = n%10;
            n/=10;
            res+=mod*mod;
        }
        return res;
    }
    public boolean isHappy(int n) {
        HashSet<Integer> set = new HashSet<>();
        while(n!=1&&!set.contains(n)){
            set.add(n);
            n=sum(n);
        }
        return n==1;
    }
}
```

### 1. 两数之和

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

```java
class Solution {
 public int[] twoSum(int[] nums,int target){
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            if(map.containsKey(target-nums[i])){
                return new int[]{i,map.get(target-nums[i])};
            }
            map.put(nums[i],i);
        }
        return new int[]{};
    }
}
```

### 454. 四数相加Ⅱ

给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：

```math
(1)0 <= i, j, k, l < n;
(2)nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0
```

```java
/**四数相加
 * @author yhli3
 * @ClassName FourSumCount.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.哈希表
 * @createTime 2022年03月22日 18:51:00
 */
public class FourSumCount {
    public int fourSumCount(int[] nums1,int[] nums2,int[] nums3,int[] nums4){
        HashMap<Integer,Integer> map = new HashMap<>();
        //令nums1[i]+nums2[j]=a+b，map中的key存a+b的和，value存a+b的和出现的次数
        int n = nums1.length;
        int temp = 0;
        int count = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                temp=nums1[i]+nums2[j];
                map.put(temp,map.getOrDefault(temp,0)+1);
            }
        }
        //令nums3[k]+nums4[l]=c+d，如果map中包含-(c+d)，那么count=count+value
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                temp = nums3[i]+nums4[j];
                if(map.containsKey(-temp)){
                    count+=map.get(-temp);
                }
            }
        }
        return count;
    }
}
```

## 回溯算法

### 77. 组合

给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。
你可以按 任何顺序 返回答案。

```java
    List<List<Integer>> result = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();

    /**
     * 回溯搜索的本质是穷举，可以画一个树型结构的辅助遍历图
     * @param n
     * @param k
     * @return
     */
    public List<List<Integer>> combine(int n, int k) {
        combineHelper(n, k, 1);
        return result;
    }

    /**
     * 每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠startIndex
     * @param startIndex 用来记录本层递归中，集合从哪里开始遍历（集合就是[1,...,n] ）。
     */
    private void combineHelper(int n, int k, int startIndex){
        //终止条件
        if (path.size() == k){
            //存放结果
            result.add(new ArrayList<>(path));
            return;
        }
        //for循环横向遍历
        //剪枝优化：for (int i = startIndex; i <= n - (k - path.size()) + 1; i++)
        for (int i = startIndex; i <= n; i++){
            //处理节点
            path.add(i);
            System.out.println("递归之前=>"+path);
            //递归进行纵向遍历
            combineHelper(n, k, i + 1);
            //回溯，撤销处理结果
            path.removeLast();
            System.out.println("递归之后=>"+path);
        }
    }

    public static void main(String[] args) {
        Combine combine = new Combine();
        combine.combine(3,2);
    }
```

### 216. 组合总和Ⅲ

找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：

- 只使用数字1到9
- 每个数字 最多使用一次 
返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。

```java
   List<List<Integer>> res = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();

    public List<List<Integer>> combinationSum3(int k,int n){
        recursive(k,n,1);
        return res;
    }

    //回溯函数模板
    private void recursive(int k,int n,int index){
        //终止条件
        //剪枝优化
        if (path.stream().reduce(Integer::sum).orElse(0)>n){
            return;
        }
        if(path.stream().reduce(Integer::sum).orElse(0)==n&&path.size()==k){
            res.add(new ArrayList<>(path));
            return;
        }
        //剪枝优化：for (int i = index; i <= 3-(k- path.size())+1; i++)
        for (int i = index; i <= 9; i++) {
            //处理节点
            path.add(i);
            // System.out.println("递归之前=>"+path);
            //递归
            recursive(k,n,i+1);
            //回溯返回（递归到底了，该往上层抛）：删除最后一个元素
            path.removeLast();
            // System.out.println("递归之后=>"+path);
        }
    }
```

### 17. 电话号码的字母组合

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![电话号码的字母组合-2022-05-21-16-13-41](https://images-1309978559.cos.ap-chengdu.myqcloud.com/blogimages/电话号码的字母组合-2022-05-21-16-13-41.png)

```java
public class LetterCombinations {

    List<String> res = new ArrayList<>();
    /**
     * StringBuilder线程不安全
     */
    StringBuilder sb = new StringBuilder();

    /**
     * 求不同集合的组合，树形辅助图中的每一层为一个不同的集合
     * @param digits
     * @return
     */
    public List<String> letterCombinations(String digits){
        //判空
        if(digits==null||digits.length()==0){
            return res;
        }

        //确定回溯函数backtracking()参数:String[] s(字符串数组),String digits,index（标记每一层使用那一个数字对应的集合）
        //数字和字符串做映射
        String[] strings = {"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
        backtracking(strings,digits,0);
        return res;
    }


    /**
     * 确定单层遍历逻辑
     * @param s
     * @param digits
     * @param index
     */
    private void backtracking(String[] s,String digits,int index){
        //确定终止条件：index个数等于digits的长度
        if(index==digits.length()){
            res.add(sb.toString());
            return;
        }
        //找到数字对应的字符串
        String str = s[digits.charAt(index)-'0'];
        //for循环
        for (int i = 0; i < str.length(); i++) {
            //处理节点
            sb.append(str.charAt(i));
            //递归
            backtracking(s,digits,index+1);
            //回溯返回
            sb.deleteCharAt(sb.length()-1);
        }
    }
}
```

## 贪心算法

### 455. 分发饼干

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

```java
public class FindContentChildren {
    /**
     * 贪心思想
     * 局部最优：尺寸大的饼干优先满足大胃口的孩子
     * @param g
     * @param s
     * @return
     */
    public int findContentChildren(int[] g,int[] s){
        //将数组s和g升序排列
        Arrays.sort(g);
        Arrays.sort(s);
        int index = s.length-1;
        int count = 0;
        for (int i = g.length-1; i >= 0; i--) {
            if(index>=0&&g[i]<=s[index]){
                index--;
                count++;
            }
        }
        return count;
    }
}
//解法二：
   /**
     * 贪心思想
     * 局部最优：尺寸小的饼干优先满足小胃口的孩子
     * @param g
     * @param s
     * @return
     */
    public static int findContentChildren(int[] g,int[] s){
        //将数组s和g升序排列
        Arrays.sort(g);
        Arrays.sort(s);
        int index = 0;
        int count = 0;
        for (int i = 0; i < s.length&&index<g.length; i++) {
            if(s[i]>=g[index]){
                count++;
                index++;
            }
        }
        return count;
    }
```

### 376. 摆动序列

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。

```java
/**局部最优：删除单调坡度上的处于中间的节点，则这个坡度有两个局部峰值
 * 整体最优：整个序列有多个局部峰值，从而达到最长摆动序列
 * @author yhli3
 * @ClassName WiggleMaxLength.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.贪心
 * @createTime 2022年03月26日 09:42:00
 */
public class WiggleMaxLength {
    public int wiggleMaxLength(int[] nums) {
        if(nums.length<=1){
            return nums.length;
        }
        //当前差值
        int curDiff = 0;
        //上一个差值
        int preDiff = 0;
        //count计算的是左边的峰值
        int count = 1;
        for (int i = 1; i < nums.length; i++) {
            curDiff = nums[i]-nums[i-1];
            if((curDiff>0&&preDiff<=0)||(curDiff<0&&preDiff>=0)){
                count++;
                preDiff = curDiff;
            }
        }
        return count;
    }
}
```

### 53. 最大子数组和（贪心解法）

给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。子数组是数组中的一个连续部分。

```java
/**最大子序列和
 * @author yhli3
 * @ClassName MaxSubArray.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.贪心
 * @createTime 2022年03月28日 11:24:00
 */
public class MaxSubArray {
    public int maxSubArray(int[] nums){
        if(nums.length==1){
            return nums[0];
        }
        int sum = Integer.MIN_VALUE;
        int count = 0;
        for (int i = 0; i < nums.length; i++) {
            count+=nums[i];
            sum = Math.max(sum,count);
            if(count<=0){
                count = 0;
            }
        }
        return sum;
    }
}
```

### 122. 买卖股票的最佳时机Ⅱ（贪心解法）

给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。返回 你能获得的最大利润。

```java
 /**
     * 局部最优：收集每天的正利润;全局最优：得到最大利润;关键:price[2]-price[0]=(price[2]-price[1])+(price[1]-price[0])
     * @param prices
     * @return
     */
    public int maxProfit(int[] prices){
        int res = 0;
        for (int i = 0; i < prices.length-1; i++) {
            res+=Math.max(prices[i+1]-prices[i],0);
        }
        return res;
    }
```

### 55. 跳跃游戏

给定一个非负整数数组nums ，你最初位于数组的第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。

```java
 /**
     * 每次更新最大覆盖范围
     * @param nums
     * @return
     */
    public boolean canJump(int[] nums){
        int cover = 0;
        for (int i = 0; i <=cover; i++) {
            cover = Math.max(cover,i+nums[i]);
            if(nums.length-1<=cover){
                return true;
            }
        }
        return false;
    }
```

### 45. 跳跃游戏Ⅱ

给你一个非负整数数组 nums ，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。假设你总是可以到达数组的最后一个位置。

```java
  public int jump(int[] nums){
        if (nums == null || nums.length == 0 || nums.length == 1) {
            return 0;
        }
        //记录跳跃的次数
        int count=0;
        //当前的覆盖最大区域
        int curDistance = 0;
        //最大的覆盖区域
        int maxDistance = 0;
        for (int i = 0; i < nums.length; i++) {
            //在可覆盖区域内更新最大的覆盖区域
            maxDistance = Math.max(maxDistance,i+nums[i]);
            //说明当前一步，再跳一步就到达了末尾
            if (maxDistance>=nums.length-1){
                count++;
                break;
            }
            //走到当前覆盖的最大区域时，更新下一步可达的最大区域
            if (i==curDistance){
                curDistance = maxDistance;
                count++;
            }
        }
        return count;
    }
```

### 1005. K次取反后最大化的数组和

给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。重复这个过程恰好 k 次。可以多次选择同一个下标 i 。以这种方式修改数组后，返回数组 可能的最大和 。

//方法一

```java
 public int largestSumAfterKNegations(int[] nums,int k){
        Arrays.sort(nums);
        int bound = 0;
        int res = 0;
        //找到排序后数组中正数和负数的分界线
        for (int i = 0; i < nums.length; i++) {
            if(nums[i]<0){
                bound++;
            }else {
                break;
            }
        }
        if(k<=bound){
            for(int i = 0;i<k;i++){
                nums[i] = -nums[i];
            }
            //for (int num : nums) {
            //    res+=num;
            //}
            //return res;
            return Arrays.stream(nums).sum();
        }
        //如果k-bound是偶数
        if((k-bound)%2==0){
            for(int i = 0;i<bound;i++){
                nums[i] = -nums[i];
            }
            //for (int num : nums) {
            //    res+=num;
            //}
            //return res;
            return Arrays.stream(nums).sum();
        }else {
            for(int i = 0;i<bound;i++){
                nums[i] = -nums[i];
            }
            if(bound< nums.length&&bound!=0&&nums[bound]<=nums[bound-1]){
                nums[bound] = -nums[bound];
            }else if (bound< nums.length&&bound!=0&&nums[bound]>nums[bound-1]) {
                nums[bound-1] = -nums[bound-1];
            }else if(bound==0){
                nums[bound] = -nums[bound];
            }else if(bound==nums.length){
                nums[bound-1] = -nums[bound-1];
            }
            //for (int num : nums) {
            //    res+=num;
            //}
            //return res;
            return Arrays.stream(nums).sum();
        }
    }
```

//方法二

```java
 //让数组nums按照绝对值从大到小排序
        nums = Arrays.stream(nums).boxed().sorted((c1,c2)->Math.abs(c2)-Math.abs(c1)).mapToInt(Integer::intValue).toArray();
        for (int i = 0; i < nums.length; i++) {
            //遇到负数进行翻转，且k减一
            if(nums[i]<0&&k>0){
                nums[i] = -nums[i];
                k--;
            }
        }
        //将最小的数进行翻转
        if(k%2==1) nums[nums.length-1] = -nums[nums.length-1];
        return Arrays.stream(nums).sum();
```

小结：面试写算法的时候最好不要用stream。

### 134. 加油站

在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。给定两个整数数组 gas 和 cost ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则保证它是唯一 的。

```java
    /**
     * gas数组所有元素之和如果小于cost数组所有元素之和，那么无论从那个加油站开始算一定不可能跑完一圈
     * @param gas
     * @param cost
     * @return
     */
    public int canCompleteCircuit(int[] gas, int[] cost){
        int curSurSum = 0;
        int allSurSum = 0;
        int index = 0;
        //从第一个加油站开始遍历
        for (int i = 0; i < gas.length; i++) {
            curSurSum+=gas[i]-cost[i];
            allSurSum+=gas[i]-cost[i];
            //curSurSum<0，不可能是当前加油站i
            if(curSurSum<0){
                //更新起始位置
                index = (i+1)% gas.length;
                curSurSum = 0;
            }
        }
        if(allSurSum<0){
            return -1;
        }
        return index;
    }
```

### 860. 柠檬水找零

在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。注意，一开始你手头没有任何零钱。给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。

```java
public boolean lemonadeChange(int[] bills){
        int five = 0;
        int ten = 0;
        int twenty = 0;
        for (int i = 0; i < bills.length; i++) {
            if(bills[i]==5){
                five++;
            }
            if(bills[i]==10){
                if(five<=0){
                    return false;
                }
                five--;
                ten++;
            }
            //贪心：如果顾客给的是20元，优先找给客户一张十元和一张五元，其次是三张五元
            if(bills[i]==20){
                if(five>0&&ten>0){
                    five--;
                    ten--;
                    twenty--;
                }else if(five>=3){
                    five-=3;
                }else {
                    return false;
                }
            }
        }
        return true;
    }
```

//更加优雅的代码

```java
//可以不用声明twenty这个变量
 public boolean lemonadeChange(int[] bills){
        int five = 0,ten = 0;
        for (int i = 0; i < bills.length; i++) {
            if(bills[i]==5) five++;
            if(bills[i]==10){
                if(five<=0) return false;
                five--;
                ten++;
            }
            //贪心：如果顾客给的是20元，优先找给客户一张十元和一张五元，其次是三张五元
            if(bills[i]==20){
                if(five>0&&ten>0){
                    five--;
                    ten--;
                }else if(five>=3){
                    five-=3;
                }else {
                    return false;
                }
            }
        }
        return true;
    }
```

### 406. 根据身高重建队列

假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面正好有 ki 个身高大于或等于 hi 的人。请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。

![根据身高重建队列-2022-05-10-14-17-58](https://images-1309978559.cos.ap-chengdu.myqcloud.com/blogimages/根据身高重建队列-2022-05-10-14-17-58.png)

```java
    public int[][] reconstructQueue(int[][] people){
        // 身高从大到小排（身高相同k小的站前面）
        Arrays.sort(people, (a, b) -> {
            if (a[0] == b[0]) return a[1] - b[1];
            return b[0] - a[0];
        });
        
        LinkedList<int[]> que = new LinkedList<>();
        //add(index,element)：在指定位置index处插入元素element，如果que中已经存在index,那么将已存在的index及其后面的元素往后移动（即索引加一）
        for (int[] p : people) {
            que.add(p[1],p);
        }

        return que.toArray(new int[people.length][]);
    }
```

### 452. 用最少数量的箭引爆气球

有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。

![用最少数量的箭引爆气球-2022-05-10-21-26-02](https://images-1309978559.cos.ap-chengdu.myqcloud.com/blogimages/用最少数量的箭引爆气球-2022-05-10-21-26-02.png)

```java
 /**
     * 局部最优：当气球出现重叠时一起射，所用弓箭最少；全局最优：全部射爆气球所用弓箭最少
     * @param points
     * @return
     */
    public static int findMinArrowShots(int[][] points){
        if (points.length == 0) return 0;
        //{{10, 16}, {2, 8}, {1, 6}, {7, 12}};排序后为{{1, 6},{2, 8},{7, 12},{10, 16}};
        Arrays.sort(points, (o1, o2) -> Integer.compare(o1[0], o2[0]));

        int count = 1;
        for (int i = 1; i < points.length; i++) {
            if (points[i][0] > points[i - 1][1]) {
                count++;
            } else {
                points[i][1] = Math.min(points[i][1],points[i - 1][1]);
            }
        }
        return count;
    }
```

### 435. 无重叠区间（难度较大）

给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。

```java
 public int eraseOverlapIntervals(int[][] intervals) {
        Arrays.sort(intervals, (a, b) -> {
            if (a[0] == a[0]) return a[1] - b[1];
            return a[0] - b[0];
        });

        int count = 0;
        int edge = Integer.MIN_VALUE;
        for (int i = 0; i < intervals.length; i++) {
            if (edge <= intervals[i][0]) {
                edge = intervals[i][1];
            } else {
                count++;
            }
        }

        return count;
    }
```

### 763. 划分字母区间

字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。

```java
   public static List<Integer> partitionLabels(String s){
        List<Integer> list = new ArrayList<>();
        //定义一个长度为26的数组，从第一个元素开始，每个位置的元素依次为a,b,c,d...
        int[] edge = new int[26];
        char[] chars = s.toCharArray();
        //统计字符串s中每个字符最后出现的位置，例如edge[0]==8表示字符串s中的字符a最后出现的位置在下标为8的地方
        for (int i = 0; i < chars.length; i++) {
            edge[chars[i]-'a'] = i;
        }
        int idx = 0;
        int last = 0;
        for (int i = 0; i < chars.length; i++) {
            idx = Math.max(idx,edge[chars[i]-'a']);
            if(idx==i){
                list.add(i-last+1);
                last = i+1;
            }
        }
        return list;
    }
```

### 56. 合并区间

以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。

```java
 public int[][] merge(int[][] intervals) {
        List<int[]> res = new LinkedList<>();
        //按照左边界进行排序
        Arrays.sort(intervals, (o1, o2) -> Integer.compare(o1[0], o2[0]));
        int start = intervals[0][0];
        for (int i = 1; i < intervals.length; i++) {
            if (intervals[i][0] > intervals[i - 1][1]) {
                res.add(new int[]{start, intervals[i - 1][1]});
                start = intervals[i][0];
            } else {
                intervals[i][1] = Math.max(intervals[i][1], intervals[i - 1][1]);
            }
        }
        res.add(new int[]{start, intervals[intervals.length - 1][1]});
        return res.toArray(new int[res.size()][]);
    }
```

### 738. 单调递增的数字

当且仅当每个相邻位数上的数字 x 和 y 满足 x <= y 时，我们称这个整数是单调递增的。给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增 。

```java
 /**
     *System.out.println(String.join("-","li","yue","hong"));//li-yue-hong
     * @param n
     * @return
     */
    public int monotoneIncreasingDigits(int n) {
        String s = String.valueOf(n);
        char[] chars = s.toCharArray();
        int start = s.length();
        for (int i = s.length()-2; i >= 0; i--) {
            if(chars[i]>chars[i+1]){
                /**
                 *  char[] chars = {'5'};
                 *  chars[0]--;
                 *  System.out.println(chars[0]);//4
                 */
                chars[i]--;
                start = i+1;
            }
        }
        for (int i = start; i < s.length(); i++) {
            chars[i] = '9';
        }
        return Integer.parseInt(String.valueOf(chars));
    }
```

### 714. 买卖股票的最佳时机含手续费

给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最大值。注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

![买卖股票的最佳时机含手续费-2022-05-17-21-30-30](https://images-1309978559.cos.ap-chengdu.myqcloud.com/blogimages/买卖股票的最佳时机含手续费-2022-05-17-21-30-30.png)

```java
//了解一下贪心的思想，一般还是用动规来做
 public int maxProfit(int[] prices,int fee){
        int buy = prices[0] + fee;
        int sum = 0;
        for (int p : prices) {
            if (p + fee < buy) {
                buy = p + fee;
            } else if (p > buy){
                sum += p - buy;
                buy = p;
            }
        }
        return sum;
    }
```

## 动态规划

### 509. 斐波那契数

斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n > 1 给你n ，请计算 F(n) 。

```java

/**斐波那契数
 * @author yhli3
 * @ClassName Fib.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年03月28日 14:54:00
 */
public class Fib {
    public int fib (int n){
        if(n<=1){
            return n;
        }
        //维护一个dp列表
        int[] dp = new int[n+1];
        //数据初始化
        dp[0] = 0;
        dp[1] = 1;
        //遍历求dp[n]的值
        for (int i = 2; i < n + 1; i++) {
            //状态转移方程
            dp[i] = dp[i-1]+dp[i-2];
        }
        return dp[n];
    }
}

```

### 70. 爬楼梯

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

```java
/**爬楼梯
 * @author yhli3
 * @ClassName ClimbStairs.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年03月28日 15:24:00
 */
public class ClimbStairs {
    public int climbStairs(int n){
        if(n<=2){
            return n;
        }
        //dp[i]代表到达第i个台阶有dp[i]种方法
        //状态转移方程：dp[i]=dp[i-1]+dp[i-2]
        int[] dp = new int[n+1];
        //dp列表初始化
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i < n + 1; i++) {
            dp[i] = dp[i-1]+dp[i-2];
        }
        return dp[n];
    }
}
```

### 741. 使用最小花费爬楼梯

给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。请你计算并返回达到楼梯顶部的最低花费。

```java
    public int minCostClimbingStairs(int[] cost) {
        //维护一个dp列表,dp[i]代表到达第i个阶梯所花费的最少费用
        //状态转移方程：dp[i] = min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2])
        int[] dp = new int[cost.length+1];
        //数据初始化
        dp[0] = 0;
        dp[1] = 0;
        for (int i = 2; i < dp.length; i++) {
            dp[i] = Math.min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]);
        }
        return dp[cost.length];
    }
```

### 62. 不同路径

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？

![不同路径-2022-05-09-20-52-43](https://images-1309978559.cos.ap-chengdu.myqcloud.com/blogimages/不同路径-2022-05-09-20-52-43.png)

```java
/**
 * @author yhli3
 * @ClassName UniquePaths.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年03月29日 09:22:00
 */
public class UniquePaths {
    public int uniquePaths(int m,int n){
        int[][] dp = new int[m][n];
        //状态转移方程：dp[i][j]=dp[i-1][j]+dp[i][j-1];
        for (int i = 0; i < n; i++) {
            dp[0][i] = 1;
        }
        for (int i = 0; i < m; i++) {
            dp[i][0] = 1;
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j]=dp[i-1][j]+dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
}
```

### 63. 不同的路径Ⅱ

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用 1 和 0 来表示。

![不同路径Ⅱ-2022-05-09-20-53-37](https://images-1309978559.cos.ap-chengdu.myqcloud.com/blogimages/不同路径Ⅱ-2022-05-09-20-53-37.png)

```java
public static int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int r = obstacleGrid.length;
        int c = obstacleGrid[0].length;
        //确定dp数组及其下标的含义
        int[][] dp = new int[r][c];

        //dp初始化
        for (int i = 0; i < r; i++) {
            if(obstacleGrid[i][0]==1){
                break;
            }
            dp[i][0] = 1;
        }

        for (int i = 0; i < c; i++) {
            if(obstacleGrid[0][i]==1){
                break;
            }
            dp[0][i] = 1;
        }

        for (int i = 1; i < r; i++) {
            for (int j = 1; j < c; j++) {
                if(obstacleGrid[i][j]==1){
                    continue;
                }
                //递推公式
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
         return dp[r-1][c-1];
}
```

### 343. 整数拆分

给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k >= 2 ），并使这些整数的乘积最大化。返回你可以获得的最大乘积 。

```java
/**
 * @author yhli3
 * @ClassName IntegerBreak.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年03月29日 15:02:00
 */
public class IntegerBreak {
    public int integerBreak(int n){
        int[] dp = new int[n + 1];
        dp[2] = 1;
        for (int i = 3; i <=n; i++) {
            for (int j = 1; j <=i-j; j++) {
                dp[i] = Math.max(dp[i],Math.max(j*(i-j),j*dp[i-j]));
            }
        }
        return dp[n];
    }
}
```

### 96. 不同的二叉搜索树

给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。

 ```java
public class NumTrees {
    public int numTrees(int n) {
        //初始化dp数组
        int[] dp = new int[n + 1];
        //初始化dp[0]和dp[1]
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            for (int j = 1; j <=i; j++) {
                //dp[i]=dp[i]+dp[j-1]*dp[i-j];定义int数组的时候，里面的元素默认初始值为0
                dp[i]+=dp[j-1]*dp[i-j];
            }
        }
        return dp[n];
    }
}
 ```

### 416. 分割等和子集

给你一个 只包含正整数的非空数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

```java
/**分割等和子集
 * @author yhli3
 * @ClassName CanPartition.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年04月05日 14:46:00
 */
public class CanPartition {
    /**
     * 背包的容量为sum/2(其中，sum为数组所有元素的和)
     * 物品、重量、价值都为nums[i]
     * @description 本质是一个01背包问题
     * @author yhli3
     * @param [nums]
     * @updateTime 2022/4/5 14:48
     * @return boolean
     */
    public boolean canPartition(int[] nums){
        //dp[j]代表容量为j的背包，可以凑成的最大子集和为dp[j]
        //dp[j]=Math.max(dp[j],dp[j-nums[i]]+nums[i])
        if(nums==null||nums.length==0){
            return false;
        }
        int totalSum = 0;
        for (int num : nums) {
            totalSum+=num;
        }
        if(totalSum%2!=0){
            return false;
        }
        int v = totalSum/2;
        int[] dp = new int[v + 1];
        //先遍历物品
        for (int i = 0; i < nums.length; i++) {
            //后遍历背包
            for (int j = v;j>=nums[i];j--){
                dp[j]=Math.max(dp[j],dp[j-nums[i]]+nums[i]);
            }
        }
        return dp[v] == v;
    }
    
}
```

### 1049. 最后一块石头的重量Ⅱ

有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：
如果 x == y，那么两块石头都会被完全粉碎；
如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。

//一维数组版本

```java
/**
 * 最后一块石头的重量Ⅱ
 *
 * @author yhli3
 * @ClassName LastStoneWeightII.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年04月07日 10:13:00
 */
public class LastStoneWeightII {
    public int lastStoneWeightII(int[] stones) {
        int sum = 0;
        for (int stone : stones) {
            sum+=stone;
        }
        int bagWeight = sum/2;
        int[] dp = new int[bagWeight+1];
        for (int i = 0; i < stones.length; i++) {
            for (int j = bagWeight; j >=stones[i]; j--) {
                dp[j] = Math.max(dp[j],dp[j-stones[i]]+stones[i]);
            }
        }
        return (sum-dp[bagWeight])-dp[bagWeight];
    }
}
```

//二维数组版本

```java
    /**
     * 二维数组版本
     * @param stones
     * @return
     */
    public int lastStoneWeightII(int[] stones) {
        int sum = 0;
        for (int stone : stones) {
            sum+=stone;
        }
        int bagWeight = sum/2;
        int[][] dp = new int[stones.length][bagWeight + 1];
        for(int j = stones[0];j<=bagWeight;j++){
            dp[0][j] = stones[0];
        }
        for (int i = 1; i < stones.length; i++) {
            for (int j = 1; j <= bagWeight; j++) {
                if(j>=stones[i]){
                    dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-stones[i]]+stones[i]);
                }else{
                    dp[i][j] = dp[i-1][j];
                }
            }
        }

        return (sum-dp[stones.length-1][bagWeight])-dp[stones.length-1][bagWeight];

    }
```

### 494. 目标和

给你一个整数数组 nums 和一个整数 target 。向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。

```java
public int findTargetSumWays(int[] nums, int target) {
        int sum = 0;
        for (int num : nums) {
            sum+=num;
        }
        if((sum+target)%2!=0||Math.abs(target)>sum){
            return 0;
        }
        int addition = (sum+target)/2;
        if(addition<0){
            addition = -addition;
        }
        //dp[j]表示装满容量为j的背包有dp[j]中方法
        int[] dp = new int[addition+1];
        dp[0] = 1;
        for (int i = 0; i < nums.length; i++) {
            for(int j =addition;j>=nums[i];j--){
                dp[j]+=dp[j-nums[i]];
                //logger.info(Arrays.toString(dp));
            }
        }
        return dp[addition];
    }
```

### 474. 一和零

给你一个二进制字符串数组 strs 和两个整数 m 和 n 。请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。

```java
/**474. 一和零
 * @author yhli3
 * @ClassName FindMaxForm.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年04月09日 19:28:00
 */
public class FindMaxForm {
    public int findMaxForm(String[] strs,int m,int n){
        //背包有两个维度
        //dp[i][j]表示最多有i个0，j个1的背包（字符串数组）的最大子集的长度
        int[][] dp = new int[m + 1][n + 1];
        int oneNum;
        int zeroNum;
        //01背包先遍历物品，即数组中的元素
        for (String str : strs) {
            oneNum = 0;
            zeroNum = 0;
            for (char c : str.toCharArray()) {
                if(c == '0'){
                    zeroNum++;
                }else{
                    oneNum++;
                }
            }
            //遍历背包
            for (int i = m; i >=zeroNum; i--) {
                for (int j = n; j >=oneNum; j--) {
                    dp[i][j] = Math.max(dp[i][j],dp[i-zeroNum][j-oneNum]+1);
                }
            }
        }
        return dp[m][n];
    }
}
```

### 518. 零钱兑换Ⅱ

给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。假设每一种面额的硬币有无限个。 题目数据保证结果符合 32 位带符号整数。

```java
/**
 * 完全背包：求填满背包的方法数
 * @author yhli3
 * @ClassName ChangeII.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年04月10日 16:09:00
 */
public class ChangeII {

    private static Logger logger = LoggerFactory.getLogger(ChangeII.class);

    public static int change(int amount,int[] coins){
         //dp[j] = Math.max(dp[j],dp[j-coins[i]]+1)
         int[] dp = new int[amount + 1];
         //初始化
         dp[0] = 1;
         //先遍历物品
         for (int i = 0; i < coins.length; i++) {
             //在遍历背包，因为是完全背包，因此需要正向遍历
             for(int j =coins[i];j<=amount;j++){
                 //求装满背包有多少种方法的递推公式
                 dp[j] += dp[j - coins[i]];
                 logger.info(Arrays.toString(dp));
             }
         }
         return dp[amount];
    }

    public static void main(String[] args) {
        int[] coins = {1, 2, 5};
        int amount = 5;
        change(amount,coins);
    }

}
```

### 377. 组合总和Ⅳ

给你一个由不同整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。题目数据保证答案符合 32 位整数范围。

```java
/**求装满背包有多少种装法，如果有顺序要求，就先遍历背包，在遍历物品
 * @author yhli3
 * @ClassName CombinationSum4.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年04月12日 10:20:00
 */
public class CombinationSum4 {

    private static Logger logger = LoggerFactory.getLogger(CombinationSum4.class);

    public static int combinationSum4(int[] nums, int target){
        int[] dp = new int[target + 1];
        dp[0] = 1;
        //先遍历背包
        for(int j = 0;j<=target;j++){
            //在遍历物品
            for (int i = 0; i < nums.length; i++) {
                if(j>=nums[i]){
                    dp[j]+=dp[j-nums[i]];
                    logger.info(Arrays.toString(dp));
                }
            }
        }
        return dp[target];
    }

    public static void main(String[] args) {
        int[] nums = {1, 2, 3};
        int target = 4;
        combinationSum4(nums,target);
    }

}
```

### 70. 爬楼梯（进阶版）

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

```java
/**可以看成是一个完全背包问题
 * @author yhli3
 * @ClassName ClimbStairsByBag.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年04月13日 10:54:00
 */
public class ClimbStairsByBag {

    public int climbStairs(int n){
        //台阶就是物品
        int[] weight = {1, 2};
        //楼顶相当于背包
        int[] dp = new int[n + 1];
        //初始化（关键）
        dp[0] = 1;
        //先遍历背包
        for(int j = 0;j<=n;j++){
            //在遍历物品
            for (int i = 0; i < weight.length; i++) {
                if(j>=weight[i]){
                    dp[j]+=dp[j-weight[i]];
                }
            }
        }
        return dp[n];
    }

}
```

### 322. 零钱兑换

给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。你可以认为每种硬币的数量是无限的。

```java
/**
 * @author yhli3
 * @ClassName CoinChange.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年04月13日 11:24:00
 */
public class CoinChange {
    public int coinChange(int[] coins, int amount) {
        if(amount==0){
            return 0;
        }
        //dp[j] = Math.min(dp[j-coins[i]]+1,dp[j])
        int[] dp = new int[amount+1];
        //初始化
        dp[0] = 0;
        for(int i =1;i<dp.length;i++){
            dp[i] = Integer.MAX_VALUE;
        }
        //先遍历物品
        for(int i =0;i<coins.length;i++){
            //后遍历背包
            for(int j = 0;j<=amount;j++){
                //Integer.MAX_VALUE==2147483647
                //Integer.MIN_VALUE==-2147483648
                //Integer.MAX_VALUE+1 == -2147483648
                if(j>=coins[i]&&dp[j-coins[i]]!=Integer.MAX_VALUE){
                    dp[j] = Math.min(dp[j-coins[i]]+1,dp[j]);
                }
            }
        }

        return dp[amount]==Integer.MAX_VALUE?-1:dp[amount];

    }
}
```

### 279. 完全平方数

给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

```java

/**279.完全平方数
 * @author yhli3
 * @ClassName NumSquares.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年04月14日 15:18:00
 */
public class NumSquares {

    private static Logger logger = LoggerFactory.getLogger(NumSquares.class);

    public static int numSquares(int n){
        //dp[j]代表凑满容量为j的背包，所需要最少的完全平方数的个数
        //递推公式：dp[j] = Math.min(dp[j],dp[j-i*i]+1)
        int[] dp = new int[n + 1];
        //初始化
        dp[0] = 0;
        for (int i = 1; i < dp.length; i++) {
            dp[i] = Integer.MAX_VALUE;
        }
        //先遍历物品
        for (int i = 1; i <= n; i++) {
            //后遍历背包
            for(int j = i*i;j<=n;j++){
                if(dp[j-i*i]!=Integer.MAX_VALUE){
                    dp[j] = Math.min(dp[j],dp[j-i*i]+1);
                    logger.info(Arrays.toString(dp));
                }
            }
        }
        return dp[n];
    }

    public static void main(String[] args) {
        int a = 12;
        numSquares(a);
    }

}
```

### 139. 单词拆分

给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

```java
public class WordBreak {

    private static Logger logger = LoggerFactory.getLogger(WordBreak.class);

    public static boolean wordBreak(String s, List<String> wordDict) {
        //dp[j]:长度为j的字符串是否可由字典中的元素拼接而成

        //递推公式:if(dp[j]==true&&wordDict.contains(s.substring(j,i)))，推出dp[i]==true
        //对递推公式进行翻译：如果字符串s中的前0到j-1个字符可以由字典拼接而成，后j到i-1个字符也可以由字典拼接而成，那么s中的前i个字符可以由字典拼接而成，即dp[i]=true;

        boolean[] dp = new boolean[s.length() + 1];
        dp[0] = true;
//        //先背包
//        for (int j = 1; j <= s.length(); j++) {
//            //在物品
//            for (int i = 0; i <= j; i++) {
//                if (wordDict.contains(s.substring(i,j)) && dp[i]) {
//                    dp[j] = true;
//                    logger.info(Arrays.toString(dp));
//                }
//            }
//        }
        //先物品
        for (int i = 0; i <s.length(); i++) {
            //在背包
            for(int j = 1;j< dp.length;j++){
                if (j>=i && wordDict.contains(s.substring(i,j)) && dp[i]) {
                    dp[j] = true;
                    logger.info(Arrays.toString(dp));
                }
            }
        }
        return dp[s.length()];
    }

    public static void main(String[] args) {
        String s = "leetcode";
        List<String> list = new ArrayList<String>(){{
           add("leet");
           add("code");
        }};
        wordBreak(s,list);
    }
}
```

### 198. 打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

```java
 public int rob(int[] nums){
        //dp[j]：打劫前j家（包括j）房屋(房屋从0开始编号)的最大收益为dp[j]

        //dp[j] = Math.max(dp[j-2]+nums[j],dp[j-1])

        //初始化：dp[0] = nums[0],dp[1] = Math.max(nums[0],nums[1])

        //遍历顺序：从前往后遍历

        //举例推导dp数组

        if(nums==null||nums.length==0){
            return 0;
        }

        if(nums.length==1){
            return nums[0];
        }

        int[] dp = new int[nums.length];

        dp[0] = nums[0];

        dp[1] = Math.max(nums[0],nums[1]);

        for (int j = 2; j < nums.length; j++) {
            dp[j] = Math.max(dp[j-2]+nums[j],dp[j-1]);
        }

        return dp[nums.length-1];

    }
```

### 213. 打家劫舍Ⅱ

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。

```java
 public static int rob(int[] nums){
        //dp[j]：打劫前j家（包括j）房屋(房屋从0开始编号)的最大收益为dp[j]

        //dp[j] = Math.max(dp[j-2]+nums[j],dp[j-1])

        //初始化：dp[0] = nums[0],dp[1] = Math.max(nums[0],nums[1])

        //遍历顺序：从前往后遍历

        //举例推导dp数组

        if(nums==null||nums.length==0){
            return 0;
        }

        if(nums.length==1){
            return nums[0];
        }

        int[] dp = new int[nums.length];

        int[] dp1 = new int[nums.length];

        //打劫第一家
        dp[0] = nums[0];
        dp[1] = nums[0];
        for (int j = 2; j < nums.length-1; j++) {
            dp[j] = Math.max(dp[j-2]+nums[j],dp[j-1]);
        }
        //不打劫第一家
        dp1[0] = 0;
        dp1[1] = nums[1];
        for (int j = 2; j < nums.length; j++) {
            dp1[j] = Math.max(dp1[j-2]+nums[j],dp1[j-1]);
        }
        return Math.max(dp[nums.length-2],dp1[nums.length-1]);
    }

```

### 337. 打家劫舍Ⅲ

小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。

```java
    private static Logger logger = LoggerFactory.getLogger(Rob3.class);

    // 3.状态标记递归
    // 执行用时：0 ms , 在所有 Java 提交中击败了 100% 的用户
    // 不偷：Max(左孩子不偷，左孩子偷) + Max(又孩子不偷，右孩子偷)
    // root[0] = Math.max(rob(root.left)[0], rob(root.left)[1]) +
    // Math.max(rob(root.right)[0], rob(root.right)[1])
    // 偷：左孩子不偷+ 右孩子不偷 + 当前节点偷
    // root[1] = rob(root.left)[0] + rob(root.right)[0] + root.val;

    public static int rob3(TreeNode root) {
        int[] res = robAction1(root);
        return Math.max(res[0], res[1]);
    }

    static int[] robAction1(TreeNode root) {
        logger.info("当前节点的值：{}",root==null?null:root.val);
        //1
        int res[] = new int[2];
        //2
        if (root == null) return res;
        //3
        int[] left = robAction1(root.left);
        logger.info("left数组：{}",Arrays.toString(left));
        //4
        int[] right = robAction1(root.right);
        logger.info("right数组：{}",Arrays.toString(right));
        //5
        res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
        //6
        res[1] = root.val + left[0] + right[0];
        //7
        logger.info("res数组：{}",Arrays.toString(res));
        return res;
    }

    public static void main(String[] args) {
        Integer[] array = {3,2,3,null,3,null,1};
        rob3(TreeUtil.createTree(array));
    }

```

### 121. 买卖股票的最佳时机

给定一个数组 prices ，它的第i个元素prices[i] 表示一支给定股票第 i 天的价格。你只能选择某一天买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

```java
public class MaxProfit {

    public int maxProfit(int[] prices){
        //默认初始时口袋中的钱为0
        //dp[i][0]:第i天持有股票，口袋中的钱为dp[i][0]
        //dp[i][1]:第i天不持有股票，口袋中的钱为dp[i][1]
        //dp[i][0] = Math.max(-prices[i],dp[i-1][0])
        //dp[i][1] = Math.max(prices[i]+dp[i-1][0],dp[i-1][1])

        if(prices == null || prices.length==0){
            return 0;
        }

        int length = prices.length;

        int[][] dp = new int[length][2];

        dp[0][0] = -prices[0];
        dp[0][1] = 0;

        for (int i = 1; i < length; i++) {
            dp[i][0] = Math.max(-prices[i],dp[i-1][0]);
            dp[i][1] = Math.max(prices[i]+dp[i-1][0],dp[i-1][1]);
        }
        return dp[length-1][1];
    }
    
}
```

### 122. 买卖股票的最佳时机Ⅱ

给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。在每一天，你可以决定是否购买和/或出售股票。你在任何时候最多只能持有一股股票。你也可以先购买，然后在 同一天 出售。返回你能获得的最大利润 。

```java
/**
 * @author yhli3
 * @ClassName MaxProfit2.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年04月22日 19:33:00
 */
public class MaxProfit2 {

    public int maxProfit(int[] prices){
        int n = prices.length;
        int[][] dp = new int[n][2];

        //dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]-prices[i])
        //dp[i][1] = Math.max(dp[i-1][1],prices[i]+dp[i-1][0])

        dp[0][0] = -prices[0];
        dp[0][1] = 0;

        for (int i = 1; i < n; i++) {
            dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]-prices[i]);
            dp[i][1] = Math.max(dp[i-1][1],prices[i]+dp[i-1][0]);
        }

        return dp[n-1][1];

    }

}

```

### 123. 买卖股票的最佳时机Ⅲ

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。**你最多可以完成两笔交易**。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

```java
 public int maxProfit(int[] prices){
        if(prices==null||prices.length==0){
            return 0;
        }
        /**
         * 初始时口袋中的钱为0
         * dp[i][j]:第i+1天，第j种状态时口袋中的现金为dp[i][j]
         * 五种状态：
         * 0：没有操作，1：第一次买入，2：第一次卖出，3：第二次买入，4：第二次卖出
         */
        int[][] dp = new int[prices.length][5];

        //初始化
        dp[0][1] = -prices[0];
        dp[0][2] = 0;
        dp[0][3] = -prices[0];
        dp[0][4] = 0;

        /**
         * 初始时现金为0，那么买入股票的时候，dp[i][1]或dp[i][3]一定为负数，计算利润的时候就不难理解为什么会出现prices[i]+dp[i-1][1]和prices[i]+dp[i-1][3]
         */
        for(int i = 1;i<prices.length;i++){
            /**
             * dp[i][1]可以分为两种情况：1.前一天（i-1）已经买入；2. 第i天才买入
             */
            dp[i][1] = Math.max(dp[i-1][1],-prices[i]);
            dp[i][2] = Math.max(dp[i-1][2],prices[i]+dp[i-1][1]);
            dp[i][3] = Math.max(dp[i-1][3],dp[i-1][2]-prices[i]);
            dp[i][4] = Math.max(dp[i-1][4],prices[i]+dp[i-1][3]);
        }
        return dp[prices.length-1][4];
    }
```

### 188. 买卖股票的最佳时机Ⅳ

给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

```java
    public int maxProfit(int k,int[] prices){
        if(prices==null||prices.length==0){
            return 0;
        }

        /**
         * 初始时口袋中的钱为0
         * dp[i][j]:第i+1天，第j种状态时口袋中的现金为dp[i][j]
         * 2k+1种状态：
         * 0：没有操作，1：第一次买入，2：第一次卖出，3：第二次买入，4：第二次卖出......
         */
        int[][] dp = new int[prices.length][2*k+1];

        //初始化


        for (int i = 1; i < 2*k; i+=2) {
            dp[0][i] = -prices[0];
        }

        /**
         * 初始时现金为0，那么买入股票的时候，dp[i][1]或dp[i][3]一定为负数，计算利润的时候就不难理解为什么会出现prices[i]+dp[i-1][1]和prices[i]+dp[i-1][3]
         * dp[i][1]可以分为两种情况：1.前一天（i-1）已经买入；2. 第i天才买入
         */
        for(int i = 1;i<prices.length;i++){
            for (int j =1;j<=2*k;j+=2){
                dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-1]-prices[i]);
                dp[i][j+1] = Math.max(dp[i-1][j+1],prices[i]+dp[i-1][j]);
            }
            //dp[i][1] = Math.max(dp[i-1][1],-prices[i]);
            //dp[i][2] = Math.max(dp[i-1][2],prices[i]+dp[i-1][1]);
            //dp[i][3] = Math.max(dp[i-1][3],dp[i-1][2]-prices[i]);
            //dp[i][4] = Math.max(dp[i-1][4],prices[i]+dp[i-1][3]);
        }
        return dp[prices.length-1][2*k];
    }
```

### 309. 最佳买卖股票时机含冷冻期

给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。​设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）：卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）

```java
    /**
     * 分为四种状态：
     * 0. 买入股票状态（今天买入或者之前就买入了）
     * 1. 两天前就卖出股票了，度过了冷冻期，一直没有操作，今天保持卖出股票状态
     * 2. 今天卖出股票
     * 3. 冷冻期状态
     * @param prices
     * @return
     */
    public int maxProfit(int[] prices){

        if(prices==null||prices.length<2){
            return 0;
        }

        int[][] dp = new int[prices.length][4];
        dp[0][0] = -prices[0];
        for (int i = 1; i < prices.length; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], Math.max(dp[i - 1][3], dp[i - 1][1]) - prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][3]);
            dp[i][2] = dp[i - 1][0] + prices[i];
            dp[i][3] = dp[i - 1][2];
        }
        
        return Math.max(dp[prices.length-1][3],Math.max(dp[prices.length-1][1], dp[prices.length-1][2]));

    }
```

### 714. 买卖股票的最佳时机含手续费

给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最大值。注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

```java
public int maxProfit(int[] prices, int fee){

        //默认初始时口袋中的钱为0
        //dp[i][0]:第i天持有股票状态，口袋中的钱为dp[i][0]
        //dp[i][1]:第i天不持有股票状态，口袋中的钱为dp[i][1]

        //dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]-prices[i])
        //dp[i][1] = Math.max(dp[i-1][1],prices[i]+dp[i-1][0])
        int n = prices.length;
        int[][] dp = new int[n][2];

        //初始化
        dp[0][0] = -prices[0];
        dp[0][1] = 0;

        for (int i = 1; i < n; i++) {
            dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]-prices[i]);
            //和买卖股票的最佳时机Ⅱ的区别是多减了一个fee
            dp[i][1] = Math.max(dp[i-1][1],prices[i]+dp[i-1][0]-fee);
        }

        return dp[n-1][1];
    }
```

### 300. 最长递增子序列

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

```java
public class LengthOfLIS {

    private static Logger logger = LoggerFactory.getLogger(LengthOfLIS.class);

    public static int lengthOfLIS(int[] nums) {
        //dp[i]：nums中，0到i这个子区间内最长上升子序列的长度为dp[i]
        int[] dp = new int[nums.length];
        Arrays.fill(dp, 1);
        for (int i = 0; i < dp.length; i++) {
            for (int j = 0; j < i; j++) {
                //递推公式
                if (nums[i] > nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                    logger.info(Arrays.toString(dp));
                }
            }
        }
        int res = 0;
        for (int i = 0; i < dp.length; i++) {
            res = Math.max(res, dp[i]);
        }
        return res;
    }

    //测试
    public static void main(String[] args) {
        int[] array = {10, 9, 2, 5, 3, 7, 101, 18};
        lengthOfLIS(array);
    }

}

```

### 674. 最长连续递增序列

给定一个未经排序的整数数组，找到最长且连续递增的子序列，并返回该序列的长度。连续递增的子序列可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。

```java
    public int findLengthOfLCIS(int[] nums){
        //dp[i]：数组中以i结尾(起点不一定是i==0的位置)的子数组的最长连续递增子序列的长度为dp[i]
        //递推公式：if(nums[i+1]>nums[i]) dp[i+1] = dp[i] + 1;
        int[] dp = new int[nums.length];
        Arrays.fill(dp,1);
        for (int i = 0; i < nums.length-1; i++) {
            if(nums[i+1]>nums[i]){
                dp[i+1] = dp[i] + 1;
            }
        }
        int res = 0;
        for (int i : dp) {
            res = Math.max(i,res);
        }
        return res;
    }
```

### 718. 最长重复子数组

给两个整数数组 nums1 和 nums2 ，返回两个数组中公共的 、长度最长的子数组的长度 。

```java
public int findLength(int[] nums1, int[] nums2) {
        //dp[i][j]：以i-1结尾的子数组a和以j-1结尾的子数组b的最长公共后缀子数组的长度为dp[i][j]
        int result = 0;
        int[][] dp = new int[nums1.length + 1][nums2.length + 1];

        for (int i = 1; i < nums1.length + 1; i++) {
            for (int j = 1; j < nums2.length + 1; j++) {
                if (nums1[i - 1] == nums2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                    result = Math.max(result, dp[i][j]);
                }
            }
        }
        return result;
    }
```

### 1143. 最长公共子序列

给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。如果不存在公共子序列 ，返回 0 。一个字符串的子序列是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的公共子序列是这两个字符串所共同拥有的子序列。


```java
 /**
     * 子序列可以是不连续的，子数组或子字符串需要是连续的
     * @param text1
     * @param text2
     * @return
     */
    public int longestCommonSubsequence(String text1,String text2){
        //dp[i][j]:以i-1结尾的前缀字串A和以j-1结尾的前缀字串B的最长公共子序列长度为dp[i][j]
        int[][] dp = new int[text1.length() + 1][text2.length() + 1];
        for (int i = 1; i <= text1.length(); i++) {
            for (int j = 1; j <= text2.length(); j++) {
                if(text1.charAt(i-1)==text2.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1] + 1;
                }else {
                    //ace和bc的最长公共子序列的长度为取ac和bc、ace和b中的最长公共子序列的长度的最大值
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[text1.length()][text2.length()];
    }
```

### 1035. 不相交的线

在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足：nums1[i] == nums2[j]；且绘制的直线不与任何其他连线（非水平线）相交。请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。以这种方法绘制线条，并返回可以绘制的最大连线数。

```java

    /**
     * 本质和求两个字符串的最长公共子序列一样
     * @param nums1
     * @param nums2
     * @return
     */
    public int maxUncrossedLines(int[] nums1, int[] nums2){
        //dp[i][j]:以i-1结尾的前缀子数组A和以j-1结尾的前缀子数组B的最长公共子序列长度为dp[i][j]
        int[][] dp = new int[nums1.length + 1][nums2.length + 1];
        for (int i = 1; i <= nums1.length; i++) {
            for (int j = 1; j <= nums2.length; j++) {
                if(nums1[i-1]==nums2[j-1]){
                    dp[i][j] = dp[i-1][j-1] + 1;
                }else {
                    //ace和bc的最长公共子序列的长度为取ac和bc、ace和b中的最长公共子序列的长度的最大值
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[nums1.length][nums2.length];
    }
```

### 53. 最大子数组和（动规解法）

给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
子数组 是数组中的一个连续部分。

```java
public static int maxSubArray(int[] nums) {
        //dp[i]表示以nums[i]结尾的连续子数组的最大和（是要包括nums[i]在内的连续子数组）
        //dp[i] = Math.max(nums[i],dp[i-1]+nums[i])
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        for (int i = 1; i < nums.length; i++) {
            dp[i] = Math.max(nums[i],dp[i-1]+nums[i]);
            // logger.info(Arrays.toString(dp));
        }
        //res初始化为nums[0]避免出现传进来的数组只有一个元素，例如{-1}
        int res = nums[0];
        for (int i : dp) {
            res = Math.max(res,i);
        }
        return res;
    }
```

### 392. 判断子序列

给定字符串 s 和 t ，判断 s 是否为 t 的子序列。字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。
进阶：如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？

```java
//本质就是求两个字符串的最长公共子序列的长度，如果最长公共子序列的长度和字符串s的长度相等，那么返回true
  public boolean isSubsequence(String s, String t) {
        //dp[i][j]:以下标i-1结尾的前缀字串A和以下标j-1结尾的前缀字串B的最长公共子序列的长度为dp[i][j]
        //如果把dp[i][j]定义为以下标i结尾的前缀字串A和以下标j结尾的前缀字串B的最长公共子序列的长度为dp[i][j]，那么对dp[0][j]和dp[i][0]的初始化很麻烦
        int[][] dp = new int[s.length()+1][t.length()+1];
        int res = 0;
        for(int i = 1;i<=s.length();i++){
            for(int j = 1;j<=t.length();j++){
                if(s.charAt(i-1)==t.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1] + 1;
                }else{
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                }
                res = res>dp[i][j]?res:dp[i][j];
            }
        }
        if(res==s.length()){
            return true;
        }
        return false;
    }
```

### 583. 两个字符串的删除操作

给定两个单词 word1 和 word2 ，返回使得 word1 和  word2 相同所需的最小步数。每步可以删除任意一个字符串中的一个字符。

```java
    /**
     * 本质与求两个字符串的最长公共子序列的长度类似
     * @param word1
     * @param word2
     * @return
     */
    public int minDistance(String word1, String word2){
        int[][] dp = new int[word1.length() + 1][word2.length()+1];
        for (int i = 1; i <= word1.length(); i++) {
            for (int j = 1; j <= word2.length(); j++) {
                if(word1.charAt(i-1)==word2.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1]+1;
                }else{
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        //word1的长度=word1非公共子序列的长度+word1和word2公共子序列的长度
        //word2的长度=word2非公共子序列的长度+word1和word2公共子序列的长度
        //最小步数=word1非公共子序列的长度+word2非公共子序列的长度
        return word1.length()+word2.length()-2*dp[word1.length()][word2.length()];
    }
```

### 647. 回文字串

给你一个字符串 s ，请你统计并返回这个字符串中回文子串的数目。回文字符串是正着读和倒过来读一样的字符串。子字符串 是字符串中的由连续字符组成的一个序列。具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

```java
 public int countSubstrings(String s) {
        //dp[i][j]:字符串s中区间[i,j]的字串如果是一个回文串，那么dp[i][j]为true,否则为false
        boolean[][] dp = new boolean[s.length()][s.length()];
        int res = 0;
        for (int j = 0; j < s.length(); j++) {
            for(int i =0;i<=j;i++){
                if(s.charAt(i)==s.charAt(j)){
                    if(j-i<=1){
                        res++;
                        dp[i][j] = true;
                    }else if(dp[i+1][j-1]){//例如s="cabcca"，s[1]==s[5]，如果bcc为回文串，那么abcca必为回文串
                        res++;
                        dp[i][j] = true;
                    }
                }
            }
        }
        return res;
    }
```

### 516. 最长回文子序列

给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

```java
  public int longestPalindromeSubseq(String s){
        //dp[i][j]:字符串s中位于区间[i,j]的字串的最长回文子序列的长度为dp[i][j]
        int l = s.length();
        int[][] dp = new int[l+1][l+1];
        for (int i = l-1; i >= 0; i--) {
            //只有一个字符，最长回文子序列的长度为1
            dp[i][i] = 1;
            for(int j=i+1;j<l;j++){
                if(s.charAt(i)==s.charAt(j)){
                    dp[i][j] = dp[i+1][j-1] + 2;
                }else{
                    dp[i][j] = Math.max(dp[i+1][j],dp[i][j-1]);
                }
            }
        }
        return dp[0][l-1];
    }
```

## 单调栈

### 739. 每日温度

给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指在第 i 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。

```java
    /**单调栈的本质：空间换时间（与两层for循环的暴力解法相比）
     * 何时用单调栈：通常是一维数组，需要寻找某个元素右边或者左边第一个比它大或者小的元素的位置；
     * 单调栈中存放什么：存放的是数组元素的下标；
     * 从栈顶到栈底使用递增还是递减顺序：根据不同的题目具体分析，本题采用元素递增序列
     * @param temperatures
     * @return
     */
    public int[] dailyTemperatures(int[] temperatures){
        int[] res = new int[temperatures.length];
        Stack<Integer> stack = new Stack<>();
        stack.push(0);
        for (int i = 1; i < temperatures.length; i++) {
            if(temperatures[i]<=temperatures[stack.peek()]){
                stack.push(i);
            }else{
                while (!stack.empty()&&temperatures[i]>temperatures[stack.peek()]){
                    res[stack.peek()] = i-stack.peek();
                    stack.pop();
                }
                stack.push(i);
            }
        }
        return res;
    }
```

### 496. 下一个更大元素Ⅰ

nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。对于每个 0 <= i < nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的下一个更大元素 。

```java
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        int[] res = new int[nums1.length];
        //初始化res中的元素为-1
        Arrays.fill(res,-1);
        // int[] array = new int[nums2.length];
        //新建哈希表，k存nums1中的元素，v存的是元素的下标
        Map<Integer,Integer> map = new HashMap<>();
        for(int i =0;i<nums1.length;i++){
            map.put(nums1[i],i);
        }
        Stack<Integer> stack = new Stack<>();
        stack.push(0);
        for(int i = 1;i<nums2.length;i++){
            if(nums2[i]<nums2[stack.peek()]){
                stack.push(i);
            }else{
                while(!stack.empty()&&nums2[i]>nums2[stack.peek()]){
                    if(map.containsKey(nums2[stack.peek()])){
                        res[map.get(nums2[stack.peek()])] = nums2[i];
                    }
                    // array[i] = i-stack.pop();
                    stack.pop();
                }
                stack.push(i);
            }
        }
        return res;
    }
```

### 503. 下一个更大的元素 Ⅱ

给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素 。数字 x 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1 。

```java
 /**
     * 将两个数组拼接到一起，然后使用单调栈求解
     * @param nums
     * @return
     */
    public int[] nextGreaterElements(int[] nums){
        int[] array = new int[nums.length * 2];
        int[] res = new int[nums.length*2];
        //快速初始化数组
        Arrays.fill(res,-1);
        for (int i = 0; i < nums.length; i++) {
            array[i] = nums[i];
            array[i+ nums.length] = nums[i];
        }
        Stack<Integer> stack = new Stack<>();
        stack.push(0);
        for (int i = 1; i < array.length; i++) {
            if(array[i]<=array[stack.peek()]){
                stack.push(i);
            }else{
                while(!stack.empty()&&array[i]>array[stack.peek()]){
                    res[stack.peek()] = array[i];
                    stack.pop();
                }
                stack.push(i);
            }
        }
        return Arrays.copyOfRange(res,0,res.length/2);
    }
```
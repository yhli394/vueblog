---
title: 代码随想录刷题笔记（持续更新...） 
date: 2022-2-28
tags: 
- 代码随想录
categories:
- Algorithm
- sticky: 1
---

## 数组

### 1. 二分查找

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

```java
//适用于target定义在左闭右闭的区间，即[left,right]
class Solution {
    public int search(int[] nums, int target) {
        int left =0;
        int right = nums.length-1;
        int middle;
        //如果target不在数组内部，提前做判断返回，减少后面的循环次数
        if(target<nums[0]||target>nums[nums.length-1]){
            return -1;
        }
        //注意是left<=right
        while(left<=right){
            middle = left+(right-left)/2;
            if(target==nums[middle]){
                return middle;
            }else if(target<nums[middle]){
                //如果写成right=middle，还可以进一步优化，因为target一定不等于nums[middle]，所以right=middle-1
                right=middle-1;
            }else{
                left=middle+1;
            }
        }
        return -1;
    }
}
//适用于target定义在左闭右开的区间，即[left,right)
class Solution {
    public int search(int[] nums, int target) {
        int left = 0, right = nums.length;
        //注意是left<right
        while (left < right) {
            int mid = left + ((right - left) >> 1);
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] < target)
                left = mid + 1;
            else if (nums[mid] > target)
                //注意是r
                right = mid;
        }
        return -1;
    }
}
```

### 2. 移除元素

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

```java
//暴力解法
class Solution {
    public int removeElement(int[] nums, int val) {
        int length = nums.length;
        for(int i=0;i<length;i++){     
            if(val==nums[i]){
                for(int j=i+1;j<length;j++){
                    nums[j-1]=nums[j];
                }
                i--;
                length--;
            }
        }
        return length;
    }
}
//双指针
class Solution {
    public int removeElement(int[] nums, int val) {
        int fast=0;
        int slow;
        for(slow=0;fast<nums.length;fast++){
            if(nums[fast]!=val){
                nums[slow]=nums[fast];
                slow++;
            }
        }
        return slow;
    }
}
```

### 3. 有序数组的平方

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

```java
class Solution {
    //双指针解法
    public int[] sortedSquares(int[] nums) {
        int left = 0;
        int right =nums.length-1;
        int[] res = new int[nums.length];
        int p = res.length-1;
        while(left<=right){
            if(nums[left]*nums[left]>nums[right]*nums[right]){
                res[p--]=nums[left]*nums[left];
                left++;
            }else{
                res[p--]=nums[right]*nums[right];
                right--;
            }
        }
        return res;
    }
}
时间复杂度：O(n)
空间复杂度：O(1)（不算存储数组z）或者O(n)都没问题
```

### 4. 长度最小的子数组

给定一个含有 n 个正整数的数组和一个正整数 target 。找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

```java
//滑动窗口
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        //滑动窗口和双指针类似
        //左指针
        int l=0;
        //初始化返回的结果
        int res = Integer.MAX_VALUE;
        //sum用于计算滑动窗口元素的和
        int sum=0;
        for(int r=0;r<nums.length;r++){
            sum+=nums[r];
            //判断滑动窗口的值是否大于target
            while(sum>=target){
                //计算符合条件的最小的滑动窗口大小
                res=Math.min(r-l+1,res);
                //左指针右移，缩小滑动窗口
                sum-=nums[l++];
            }
        }
        return res==Integer.MAX_VALUE?0:res;
    }
}

//暴力解法
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int res=0;
        int min=Integer.MAX_VALUE;
        Set<Integer> set = new HashSet<>();
        for(int i=0;i<nums.length;i++){
            res=nums[i];
            for(int j=i+1;j<nums.length;j++){
                if(res>=target){
                    return 1;
                }
                res+=nums[j];
                if(res>=target){
                    set.add(j-i+1);
                    break;
                }
            }  
        }
        if(nums[nums.length-1]==target){
            set.add(1);
        }
        if(set.isEmpty()){
            return 0;
        }
        for(Integer e:set){
            min=Math.min(e,min);
        }
        return min;
    }
}
```

### 5. 螺旋矩阵Ⅱ

给你一个正整数 n ，生成一个包含 1 到 n² 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。

![螺旋矩阵Ⅱ-2022-04-19-21-27-40](https://imagecontainter-1309978559.cos.ap-chengdu.myqcloud.com/blogimages/螺旋矩阵Ⅱ-2022-04-19-21-27-40.png)

![test-2022-04-19-21-47-23](www.yhli.work/blogimages/test-2022-04-19-21-47-23.png)

```java
    public stati int[][] generateMatrix(int n) {
        if(n==1) return new int[][]{{1}};
        int[][] res = new int[n][n];
        int l=0;
        int r=n-1;
        int t=0;
        int b=n-1;
        //count用来计数
        int count =1;
        int mid = n/2;
        while(true){
            //1.模拟从左向右
            for(int i=t;i<r;i++){
                res[t][i]=count++;
            }
            //上边界向内缩进一格
            if(++t>b) break;
            //2.模拟从上到下
            for(int i=l;i<b;i++){
                res[i][r]=count++;
            }
            //右边界向内缩进一格
            if(--r<l) break;
            //3.模拟从右到左
            for(int i= r+1;i>l;i--){
                res[b][i]=count++;
            }
            //下边界向内缩进一格
            //if(--b<t) break;当n=2时会出错
            if(b--<t) break;
            //4.模拟从下到上
            for(int i=b+1;i>=t;i--){
                res[i][l]=count++;
            }
            //左边界向内缩进一格
            if(++l>r) break;
        }
        if(n%2==1){
            //n为奇数，上面while中的算法会导致矩阵中心为0，因此需要手动给矩阵中心赋值
            res[mid][mid]=count;
        }
        return res;
    }
```

## 链表

### 203. 移除链表元素

给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回新的头节点 。

```java
public class ListNode{
    int val;
    ListNode next;
    ListNose(){}
    ListNode(int val){this.val=val;}
    ListNode(int val,ListNode next){this.val=val;this.next=next;}
}
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode dummy = new ListNode(0,head);
        //关键：初始时pre和dummy管理的是同一个结点
        ListNode pre = dummy;
        ListNode cur = head;
        while(cur!=null){
            if(cur.val==val){
                pre.next=cur.next;
            }else{
                pre=cur;
            }
            cur=cur.next;
        }
        return dummy.next;
    }
}
```

### 707. 设计链表的实现

您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。在链表类中实现这些功能：
get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。
addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。
addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。
addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。
deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。

```java
//自己定义一个单链表类
class ListNode{
    int val;
    ListNode next;
    ListNode(){};
    ListNode(int val){
        this.val=val;
    }
    ListNode(int val,ListNode next){
        this.val=val;
        this.next=next;
    }
}
class MyLinkedList {
    //size存储链表元素个数
    int size;
    ListNode head;
    //初始化链表
    public MyLinkedList() {
        size=0;
        head=new ListNode(0);
    }
    
    public int get(int index) {
        if(index<0||index>=size){
            return -1;
        }
        ListNode cur = head;
        for(int i=0;i<=index;i++){
            cur=cur.next;
        }
        return cur.val;
    }
    
    public void addAtHead(int val) {
        addAtIndex(0,val);
    }
    
    public void addAtTail(int val) {
        addAtIndex(size,val);
    }
 
    public void addAtIndex(int index, int val) {
        //index大于链表的长度
        if(index>size){
            return;
        }
        //index小于0
        if(index<0){
            index=0;
        }
        size++;
        //0=<index长度<=链表长度
        //找到要插入结点的前驱结点
        ListNode pre = head;
        for(int i=0;i<index;i++){
            pre=pre.next;
        }
        ListNode toAdd = new ListNode(val);
        toAdd.next = pre.next;
        pre.next=toAdd;
    }

    public void deleteAtIndex(int index) {
        //判断索引是否有效
        if(index<0||index>=size){
            return;
        }
        //找到要删除结点的前驱结点
        ListNode pre = head;
        for(int i=0;i<index;i++){
            pre=pre.next;
        }
        pre.next=pre.next.next;
        size--;
    }

}

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList obj = new MyLinkedList();
 * int param_1 = obj.get(index);
 * obj.addAtHead(val);
 * obj.addAtTail(val);
 * obj.addAtIndex(index,val);
 * obj.deleteAtIndex(index);
 */
```

### 206. 反转链表

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
         ListNode pre = null;
         ListNode temp =null;
         ListNode cur = head;
         while(cur!=null){
             temp=cur.next;
             cur.next=pre;
             pre=cur;
             cur=temp;
         }
         return pre;
    }
}
```

### 24. 两两交换链表中的结点

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummy = new ListNode(0,head);
        ListNode pre =dummy;
        while(pre.next!=null&&pre.next.next!=null){
            ListNode temp = head.next.next;
            pre.next=head.next;
            //注意理解head.next.next代表的含义
            head.next.next=head;
            head.next=temp;
            pre=head;
            head=head.next;
        }
        return dummy.next;
    }
}
```

### 19. 删除链表的倒数第N个结点

给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

```java
//思路：先求出链表的长度len，如果len=n,说明要删除的是头节点，此时需要创建一个辅助虚拟节点；其它情况是遍历找到要删除节点的前驱结点pre，然后pre.next=pre.next.next
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        int len =0;
        ListNode cur =head;
        ListNode dummy = new ListNode(0,head);
        while(head!=null){
            len++;
            head=head.next;
        }
        if(n==len){
            dummy.next=cur.next;
            return dummy.next;
        }
        for(int i=0;i<len-n-1;i++){
            cur=cur.next;
        }
        cur.next=cur.next.next;
        return dummy.next;
    }
}
//另一个思路，使用双指针，初始时slow和fast指针指向head头节点，然后将fast指针向前移动n个位置，最后同步移动slow和fast指针，fast指针指向null时，slow指针z
```

### 面试题02.07.链表相交

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。

```java
// public class ListNode{
//     int val;
//     ListNode next;
//     public ListNode(){}
//     public ListNode(int val){
//         this.val=val;
//     }
//     public ListNode(int val,ListNode next){
//         this.val=val;
//         this.next=next;
//     }
// }
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode curA = headA;
        ListNode curB = headB;
        int lenA=0;
        int lenB=0;
        //计算头节点为headA的链表的长度
        while(headA!=null){
            lenA++;
            headA=headA.next;
        }
         //计算头节点为headB的链表的长度
        while(headB!=null){
            lenB++;
            headB=headB.next;
        }
        if(lenA>=lenB){
            for(int i=0;i<lenA-lenB;i++){
                curA=curA.next;
            }
            while(curA!=curB){
                curB=curB.next;
                curA=curA.next;
            }
            return curA;
        }else{
            for(int i=0;i<lenB-lenA;i++){
                curB=curB.next;
            }
            while(curA!=curB){
                curB=curB.next;
                curA=curA.next;
            }
            return curA;
        }
    }
}
```

### 142. 环形链表Ⅱ

给定一个链表的头节点head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。不允许修改链表。

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        ListNode p1 = head;
        ListNode p2 =head;
        while(fast!=null&&fast.next!=null){
            fast=fast.next.next;
            slow=slow.next;
            if(fast==slow){
                p2=fast;
                while(p1!=p2){
                    p1=p1.next;
                    p2=p2.next;
                }
                return p1;
            }
        }
        return null;
    }
}
//备注：也可以采用哈希表，如果遇到重复的一定有h
```

## 哈希表

### 242. 有效的字母异位词

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。

```java
public class IsAnagram {
    public boolean isAnagram(String s, String t) {
        //k存的是字符，v存的是字符出现的次数
        Map<Character,Integer> maps = new HashMap<>();
        Map<Character,Integer> mapt = new HashMap<>();
        for(int i=0;i<s.length();i++){
            maps.put(s.charAt(i),maps.getOrDefault(s.charAt(i),0)+1);
        }
        for(int i=0;i<t.length();i++){
            mapt.put(t.charAt(i),mapt.getOrDefault(t.charAt(i),0)+1);
        }
        for(Character e:maps.keySet()){
            if(mapt.containsKey(e)){
                //if(maps.get(e)!=mapt.get(e))，会报错，包装器类之间的比较要用equals
                if(!maps.get(e).equals(mapt.get(e))){
                    return false;
                }
            }else{
                return false;
            }
        }
        return maps.size()!=mapt.size()?false:true;
    }
}
```

### 349. 两个数组的交集

给定两个数组 `nums1` 和 `nums2` ，返回 *它们的交集* 。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        Set<Integer> set1 = new HashSet<>();
        Set<Integer> resSet = new HashSet<>();
        for (int i : nums1) {
            set1.add(i);
        }
        for (int i : nums2) {
            if(set1.contains(i)){
                resSet.add(i);
            }
        }
        int[] res = new int[resSet.size()];
        int index = 0;
        for (Integer e : resSet) {
            //自动拆箱
            res[index++]=e;
        }
        return res;
    }
}
```

### 202. 快乐数

编写一个算法来判断一个数 n 是不是快乐数。「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果可以变为  1，那么这个数就是快乐数。如果 n 是快乐数就返回 True ；不是，则返回 False 。

```java
class Solution {
    
    public int sum(int n){
        int res=0;
        while(n!=0){
            int mod = n%10;
            n/=10;
            res+=mod*mod;
        }
        return res;
    }
    public boolean isHappy(int n) {
        HashSet<Integer> set = new HashSet<>();
        while(n!=1&&!set.contains(n)){
            set.add(n);
            n=sum(n);
        }
        return n==1;
    }
}
```

### 1. 两数之和

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

```java
class Solution {
 public int[] twoSum(int[] nums,int target){
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            if(map.containsKey(target-nums[i])){
                return new int[]{i,map.get(target-nums[i])};
            }
            map.put(nums[i],i);
        }
        return new int[]{};
    }
}
```

### 454. 四数相加Ⅱ

给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：

```math
(1)0 <= i, j, k, l < n;
(2)nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0
```

```java
/**四数相加
 * @author yhli3
 * @ClassName FourSumCount.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.哈希表
 * @createTime 2022年03月22日 18:51:00
 */
public class FourSumCount {
    public int fourSumCount(int[] nums1,int[] nums2,int[] nums3,int[] nums4){
        HashMap<Integer,Integer> map = new HashMap<>();
        //令nums1[i]+nums2[j]=a+b，map中的key存a+b的和，value存a+b的和出现的次数
        int n = nums1.length;
        int temp = 0;
        int count = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                temp=nums1[i]+nums2[j];
                map.put(temp,map.getOrDefault(temp,0)+1);
            }
        }
        //令nums3[k]+nums4[l]=c+d，如果map中包含-(c+d)，那么count=count+value
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                temp = nums3[i]+nums4[j];
                if(map.containsKey(-temp)){
                    count+=map.get(-temp);
                }
            }
        }
        return count;
    }
}
```

## 贪心算法

### 455. 分发饼干

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

```java
public class FindContentChildren {
    /**
     * 贪心思想
     * 局部最优：尺寸大的饼干优先满足大胃口的孩子
     * @param g
     * @param s
     * @return
     */
    public int findContentChildren(int[] g,int[] s){
        //将数组s和g升序排列
        Arrays.sort(g);
        Arrays.sort(s);
        int index = s.length-1;
        int count = 0;
        for (int i = g.length-1; i >= 0; i--) {
            if(index>=0&&g[i]<=s[index]){
                index--;
                count++;
            }
        }
        return count;
    }
}
//解法二：
   /**
     * 贪心思想
     * 局部最优：尺寸小的饼干优先满足小胃口的孩子
     * @param g
     * @param s
     * @return
     */
    public static int findContentChildren(int[] g,int[] s){
        //将数组s和g升序排列
        Arrays.sort(g);
        Arrays.sort(s);
        int index = 0;
        int count = 0;
        for (int i = 0; i < s.length&&index<g.length; i++) {
            if(s[i]>=g[index]){
                count++;
                index++;
            }
        }
        return count;
    }
```

### 376. 摆动序列

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。

```java
/**局部最优：删除单调坡度上的处于中间的节点，则这个坡度有两个局部峰值
 * 整体最优：整个序列有多个局部峰值，从而达到最长摆动序列
 * @author yhli3
 * @ClassName WiggleMaxLength.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.贪心
 * @createTime 2022年03月26日 09:42:00
 */
public class WiggleMaxLength {
    public int wiggleMaxLength(int[] nums) {
        if(nums.length<=1){
            return nums.length;
        }
        //当前差值
        int curDiff = 0;
        //上一个差值
        int preDiff = 0;
        //count计算的是左边的峰值
        int count = 1;
        for (int i = 1; i < nums.length; i++) {
            curDiff = nums[i]-nums[i-1];
            if((curDiff>0&&preDiff<=0)||(curDiff<0&&preDiff>=0)){
                count++;
                preDiff = curDiff;
            }
        }
        return count;
    }
}
```

### 53. 最大子数组和

给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。子数组是数组中的一个连续部分。

```java
/**最大子序列和
 * @author yhli3
 * @ClassName MaxSubArray.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.贪心
 * @createTime 2022年03月28日 11:24:00
 */
public class MaxSubArray {
    public int maxSubArray(int[] nums){
        if(nums.length==1){
            return nums[0];
        }
        int sum = Integer.MIN_VALUE;
        int count = 0;
        for (int i = 0; i < nums.length; i++) {
            count+=nums[i];
            sum = Math.max(sum,count);
            if(count<=0){
                count = 0;
            }
        }
        return sum;
    }
}
```

## 动态规划

### 509. 斐波那契数

斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n > 1 给你n ，请计算 F(n) 。

```java

/**斐波那契数
 * @author yhli3
 * @ClassName Fib.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年03月28日 14:54:00
 */
public class Fib {
    public int fib (int n){
        if(n<=1){
            return n;
        }
        //维护一个dp列表
        int[] dp = new int[n+1];
        //数据初始化
        dp[0] = 0;
        dp[1] = 1;
        //遍历求dp[n]的值
        for (int i = 2; i < n + 1; i++) {
            //状态转移方程
            dp[i] = dp[i-1]+dp[i-2];
        }
        return dp[n];
    }
}

```

### 70. 爬楼梯

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

```java
/**爬楼梯
 * @author yhli3
 * @ClassName ClimbStairs.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年03月28日 15:24:00
 */
public class ClimbStairs {
    public int climbStairs(int n){
        if(n<=2){
            return n;
        }
        //dp[i]代表到达第i个台阶有dp[i]种方法
        //状态转移方程：dp[i]=dp[i-1]+dp[i-2]
        int[] dp = new int[n+1];
        //dp列表初始化
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i < n + 1; i++) {
            dp[i] = dp[i-1]+dp[i-2];
        }
        return dp[n];
    }
}
```

### 741. 使用最小花费爬楼梯

给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。请你计算并返回达到楼梯顶部的最低花费。

```java
    public int minCostClimbingStairs(int[] cost) {
        //维护一个dp列表,dp[i]代表到达第i个阶梯所花费的最少费用
        //状态转移方程：dp[i] = min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2])
        int[] dp = new int[cost.length+1];
        //数据初始化
        dp[0] = 0;
        dp[1] = 0;
        for (int i = 2; i < dp.length; i++) {
            dp[i] = Math.min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]);
        }
        return dp[cost.length];
    }
```

### 62. 不同路径

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？

```java
/**
 * @author yhli3
 * @ClassName UniquePaths.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年03月29日 09:22:00
 */
public class UniquePaths {
    public int uniquePaths(int m,int n){
        int[][] dp = new int[m][n];
        //状态转移方程：dp[i][j]=dp[i-1][j]+dp[i][j-1];
        for (int i = 0; i < n; i++) {
            dp[0][i] = 1;
        }
        for (int i = 0; i < m; i++) {
            dp[i][0] = 1;
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j]=dp[i-1][j]+dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
}
```

### 63. 不同的路径Ⅱ

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用 1 和 0 来表示。

```java
public static int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int r = obstacleGrid.length;
        int c = obstacleGrid[0].length;
        //确定dp数组及其下标的含义
        int[][] dp = new int[r][c];

        //dp初始化
        for (int i = 0; i < r; i++) {
            if(obstacleGrid[i][0]==1){
                break;
            }
            dp[i][0] = 1;
        }

        for (int i = 0; i < c; i++) {
            if(obstacleGrid[0][i]==1){
                break;
            }
            dp[0][i] = 1;
        }

        for (int i = 1; i < r; i++) {
            for (int j = 1; j < c; j++) {
                if(obstacleGrid[i][j]==1){
                    continue;
                }
                //递推公式
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
         return dp[r-1][c-1];
}
```

### 343. 整数拆分

给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k >= 2 ），并使这些整数的乘积最大化。返回你可以获得的最大乘积 。

```java
/**
 * @author yhli3
 * @ClassName IntegerBreak.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年03月29日 15:02:00
 */
public class IntegerBreak {
    public int integerBreak(int n){
        int[] dp = new int[n + 1];
        dp[2] = 1;
        for (int i = 3; i <=n; i++) {
            for (int j = 1; j <=i-j; j++) {
                dp[i] = Math.max(dp[i],Math.max(j*(i-j),j*dp[i-j]));
            }
        }
        return dp[n];
    }
}
```

### 96. 不同的二叉搜索树

给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。

 ```java
public class NumTrees {
    public int numTrees(int n) {
        //初始化dp数组
        int[] dp = new int[n + 1];
        //初始化dp[0]和dp[1]
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            for (int j = 1; j <=i; j++) {
                //dp[i]=dp[i]+dp[j-1]*dp[i-j];定义int数组的时候，里面的元素默认初始值为0
                dp[i]+=dp[j-1]*dp[i-j];
            }
        }
        return dp[n];
    }
}
 ```

### 416. 分割等和子集

给你一个 只包含正整数的非空数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

```java
/**分割等和子集
 * @author yhli3
 * @ClassName CanPartition.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年04月05日 14:46:00
 */
public class CanPartition {
    /**
     * 背包的容量为sum/2(其中，sum为数组所有元素的和)
     * 物品、重量、价值都为nums[i]
     * @description 本质是一个01背包问题
     * @author yhli3
     * @param [nums]
     * @updateTime 2022/4/5 14:48
     * @return boolean
     */
    public boolean canPartition(int[] nums){
        //dp[j]代表容量为j的背包，可以凑成的最大子集和为dp[j]
        //dp[j]=Math.max(dp[j],dp[j-nums[i]]+nums[i])
        if(nums==null||nums.length==0){
            return false;
        }
        int totalSum = 0;
        for (int num : nums) {
            totalSum+=num;
        }
        if(totalSum%2!=0){
            return false;
        }
        int v = totalSum/2;
        int[] dp = new int[v + 1];
        //先遍历物品
        for (int i = 0; i < nums.length; i++) {
            //后遍历背包
            for (int j = v;j>=nums[i];j--){
                dp[j]=Math.max(dp[j],dp[j-nums[i]]+nums[i]);
            }
        }
        return dp[v] == v;
    }
    
}
```

### 1049. 最后一块石头的重量Ⅱ

有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：
如果 x == y，那么两块石头都会被完全粉碎；
如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。

//一维数组版本

```java
/**
 * 最后一块石头的重量Ⅱ
 *
 * @author yhli3
 * @ClassName LastStoneWeightII.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年04月07日 10:13:00
 */
public class LastStoneWeightII {
    public int lastStoneWeightII(int[] stones) {
        int sum = 0;
        for (int stone : stones) {
            sum+=stone;
        }
        int bagWeight = sum/2;
        int[] dp = new int[bagWeight+1];
        for (int i = 0; i < stones.length; i++) {
            for (int j = bagWeight; j >=stones[i]; j--) {
                dp[j] = Math.max(dp[j],dp[j-stones[i]]+stones[i]);
            }
        }
        return (sum-dp[bagWeight])-dp[bagWeight];
    }
}
```

//二维数组版本

```java
    /**
     * 二维数组版本
     * @param stones
     * @return
     */
    public int lastStoneWeightII(int[] stones) {
        int sum = 0;
        for (int stone : stones) {
            sum+=stone;
        }
        int bagWeight = sum/2;
        int[][] dp = new int[stones.length][bagWeight + 1];
        for(int j = stones[0];j<=bagWeight;j++){
            dp[0][j] = stones[0];
        }
        for (int i = 1; i < stones.length; i++) {
            for (int j = 1; j <= bagWeight; j++) {
                if(j>=stones[i]){
                    dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-stones[i]]+stones[i]);
                }else{
                    dp[i][j] = dp[i-1][j];
                }
            }
        }

        return (sum-dp[stones.length-1][bagWeight])-dp[stones.length-1][bagWeight];

    }
```

### 494. 目标和

给你一个整数数组 nums 和一个整数 target 。向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。

```java
public int findTargetSumWays(int[] nums, int target) {
        int sum = 0;
        for (int num : nums) {
            sum+=num;
        }
        if((sum+target)%2!=0||Math.abs(target)>sum){
            return 0;
        }
        int addition = (sum+target)/2;
        if(addition<0){
            addition = -addition;
        }
        //dp[j]表示装满容量为j的背包有dp[j]中方法
        int[] dp = new int[addition+1];
        dp[0] = 1;
        for (int i = 0; i < nums.length; i++) {
            for(int j =addition;j>=nums[i];j--){
                dp[j]+=dp[j-nums[i]];
                //logger.info(Arrays.toString(dp));
            }
        }
        return dp[addition];
    }
```

### 474. 一和零

给你一个二进制字符串数组 strs 和两个整数 m 和 n 。请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。

```java
/**474. 一和零
 * @author yhli3
 * @ClassName FindMaxForm.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年04月09日 19:28:00
 */
public class FindMaxForm {
    public int findMaxForm(String[] strs,int m,int n){
        //背包有两个维度
        //dp[i][j]表示最多有i个0，j个1的背包（字符串数组）的最大子集的长度
        int[][] dp = new int[m + 1][n + 1];
        int oneNum;
        int zeroNum;
        //01背包先遍历物品，即数组中的元素
        for (String str : strs) {
            oneNum = 0;
            zeroNum = 0;
            for (char c : str.toCharArray()) {
                if(c == '0'){
                    zeroNum++;
                }else{
                    oneNum++;
                }
            }
            //遍历背包
            for (int i = m; i >=zeroNum; i--) {
                for (int j = n; j >=oneNum; j--) {
                    dp[i][j] = Math.max(dp[i][j],dp[i-zeroNum][j-oneNum]+1);
                }
            }
        }
        return dp[m][n];
    }
}
```

### 518. 零钱兑换Ⅱ

给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。假设每一种面额的硬币有无限个。 题目数据保证结果符合 32 位带符号整数。

```java
/**
 * 完全背包：求填满背包的方法数
 * @author yhli3
 * @ClassName ChangeII.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年04月10日 16:09:00
 */
public class ChangeII {

    private static Logger logger = LoggerFactory.getLogger(ChangeII.class);

    public static int change(int amount,int[] coins){
         //dp[j] = Math.max(dp[j],dp[j-coins[i]]+1)
         int[] dp = new int[amount + 1];
         //初始化
         dp[0] = 1;
         //先遍历物品
         for (int i = 0; i < coins.length; i++) {
             //在遍历背包，因为是完全背包，因此需要正向遍历
             for(int j =coins[i];j<=amount;j++){
                 //求装满背包有多少种方法的递推公式
                 dp[j] += dp[j - coins[i]];
                 logger.info(Arrays.toString(dp));
             }
         }
         return dp[amount];
    }

    public static void main(String[] args) {
        int[] coins = {1, 2, 5};
        int amount = 5;
        change(amount,coins);
    }

}
```

### 377. 组合总和Ⅳ

给你一个由不同整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。题目数据保证答案符合 32 位整数范围。

```java
/**求装满背包有多少种装法，如果有顺序要求，就先遍历背包，在遍历物品
 * @author yhli3
 * @ClassName CombinationSum4.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年04月12日 10:20:00
 */
public class CombinationSum4 {

    private static Logger logger = LoggerFactory.getLogger(CombinationSum4.class);

    public static int combinationSum4(int[] nums, int target){
        int[] dp = new int[target + 1];
        dp[0] = 1;
        //先遍历背包
        for(int j = 0;j<=target;j++){
            //在遍历物品
            for (int i = 0; i < nums.length; i++) {
                if(j>=nums[i]){
                    dp[j]+=dp[j-nums[i]];
                    logger.info(Arrays.toString(dp));
                }
            }
        }
        return dp[target];
    }

    public static void main(String[] args) {
        int[] nums = {1, 2, 3};
        int target = 4;
        combinationSum4(nums,target);
    }

}
```

### 70. 爬楼梯（进阶版）

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

```java
/**可以看成是一个完全背包问题
 * @author yhli3
 * @ClassName ClimbStairsByBag.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年04月13日 10:54:00
 */
public class ClimbStairsByBag {

    public int climbStairs(int n){
        //台阶就是物品
        int[] weight = {1, 2};
        //楼顶相当于背包
        int[] dp = new int[n + 1];
        //初始化（关键）
        dp[0] = 1;
        //先遍历背包
        for(int j = 0;j<=n;j++){
            //在遍历物品
            for (int i = 0; i < weight.length; i++) {
                if(j>=weight[i]){
                    dp[j]+=dp[j-weight[i]];
                }
            }
        }
        return dp[n];
    }

}
```

### 322. 零钱兑换

给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。你可以认为每种硬币的数量是无限的。

```java
/**
 * @author yhli3
 * @ClassName CoinChange.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年04月13日 11:24:00
 */
public class CoinChange {
    public int coinChange(int[] coins, int amount) {
        if(amount==0){
            return 0;
        }
        //dp[j] = Math.min(dp[j-coins[i]]+1,dp[j])
        int[] dp = new int[amount+1];
        //初始化
        dp[0] = 0;
        for(int i =1;i<dp.length;i++){
            dp[i] = Integer.MAX_VALUE;
        }
        //先遍历物品
        for(int i =0;i<coins.length;i++){
            //后遍历背包
            for(int j = 0;j<=amount;j++){
                //Integer.MAX_VALUE==2147483647
                //Integer.MIN_VALUE==-2147483648
                //Integer.MAX_VALUE+1 == -2147483648
                if(j>=coins[i]&&dp[j-coins[i]]!=Integer.MAX_VALUE){
                    dp[j] = Math.min(dp[j-coins[i]]+1,dp[j]);
                }
            }
        }

        return dp[amount]==Integer.MAX_VALUE?-1:dp[amount];

    }
}
```

### 279. 完全平方数

给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

```java

/**279.完全平方数
 * @author yhli3
 * @ClassName NumSquares.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年04月14日 15:18:00
 */
public class NumSquares {

    private static Logger logger = LoggerFactory.getLogger(NumSquares.class);

    public static int numSquares(int n){
        //dp[j]代表凑满容量为j的背包，所需要最少的完全平方数的个数
        //递推公式：dp[j] = Math.min(dp[j],dp[j-i*i]+1)
        int[] dp = new int[n + 1];
        //初始化
        dp[0] = 0;
        for (int i = 1; i < dp.length; i++) {
            dp[i] = Integer.MAX_VALUE;
        }
        //先遍历物品
        for (int i = 1; i <= n; i++) {
            //后遍历背包
            for(int j = i*i;j<=n;j++){
                if(dp[j-i*i]!=Integer.MAX_VALUE){
                    dp[j] = Math.min(dp[j],dp[j-i*i]+1);
                    logger.info(Arrays.toString(dp));
                }
            }
        }
        return dp[n];
    }

    public static void main(String[] args) {
        int a = 12;
        numSquares(a);
    }

}
```

### 139. 单词拆分

给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

```java
public class WordBreak {

    private static Logger logger = LoggerFactory.getLogger(WordBreak.class);

    public static boolean wordBreak(String s, List<String> wordDict) {
        //dp[j]:长度为j的字符串是否可由字典中的元素拼接而成

        //递推公式:if(dp[j]==true&&wordDict.contains(s.substring(j,i)))，推出dp[i]==true
        //对递推公式进行翻译：如果字符串s中的前0到j-1个字符可以由字典拼接而成，后j到i-1个字符也可以由字典拼接而成，那么s中的前i个字符可以由字典拼接而成，即dp[i]=true;

        boolean[] dp = new boolean[s.length() + 1];
        dp[0] = true;
//        //先背包
//        for (int j = 1; j <= s.length(); j++) {
//            //在物品
//            for (int i = 0; i <= j; i++) {
//                if (wordDict.contains(s.substring(i,j)) && dp[i]) {
//                    dp[j] = true;
//                    logger.info(Arrays.toString(dp));
//                }
//            }
//        }
        //先物品
        for (int i = 0; i <s.length(); i++) {
            //在背包
            for(int j = 1;j< dp.length;j++){
                if (j>=i && wordDict.contains(s.substring(i,j)) && dp[i]) {
                    dp[j] = true;
                    logger.info(Arrays.toString(dp));
                }
            }
        }
        return dp[s.length()];
    }

    public static void main(String[] args) {
        String s = "leetcode";
        List<String> list = new ArrayList<String>(){{
           add("leet");
           add("code");
        }};
        wordBreak(s,list);
    }
}
```

### 198. 打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

```java
 public int rob(int[] nums){
        //dp[j]：打劫前j家（包括j）房屋(房屋从0开始编号)的最大收益为dp[j]

        //dp[j] = Math.max(dp[j-2]+nums[j],dp[j-1])

        //初始化：dp[0] = nums[0],dp[1] = Math.max(nums[0],nums[1])

        //遍历顺序：从前往后遍历

        //举例推导dp数组

        if(nums==null||nums.length==0){
            return 0;
        }

        if(nums.length==1){
            return nums[0];
        }

        int[] dp = new int[nums.length];

        dp[0] = nums[0];

        dp[1] = Math.max(nums[0],nums[1]);

        for (int j = 2; j < nums.length; j++) {
            dp[j] = Math.max(dp[j-2]+nums[j],dp[j-1]);
        }

        return dp[nums.length-1];

    }
```

### 213. 打家劫舍Ⅱ

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。

```java
 public static int rob(int[] nums){
        //dp[j]：打劫前j家（包括j）房屋(房屋从0开始编号)的最大收益为dp[j]

        //dp[j] = Math.max(dp[j-2]+nums[j],dp[j-1])

        //初始化：dp[0] = nums[0],dp[1] = Math.max(nums[0],nums[1])

        //遍历顺序：从前往后遍历

        //举例推导dp数组

        if(nums==null||nums.length==0){
            return 0;
        }

        if(nums.length==1){
            return nums[0];
        }

        int[] dp = new int[nums.length];

        int[] dp1 = new int[nums.length];

        //打劫第一家
        dp[0] = nums[0];
        dp[1] = nums[0];
        for (int j = 2; j < nums.length-1; j++) {
            dp[j] = Math.max(dp[j-2]+nums[j],dp[j-1]);
        }
        //不打劫第一家
        dp1[0] = 0;
        dp1[1] = nums[1];
        for (int j = 2; j < nums.length; j++) {
            dp1[j] = Math.max(dp1[j-2]+nums[j],dp1[j-1]);
        }
        return Math.max(dp[nums.length-2],dp1[nums.length-1]);
    }

```

### 337. 打家劫舍Ⅲ

小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。

```java
    private static Logger logger = LoggerFactory.getLogger(Rob3.class);

    // 3.状态标记递归
    // 执行用时：0 ms , 在所有 Java 提交中击败了 100% 的用户
    // 不偷：Max(左孩子不偷，左孩子偷) + Max(又孩子不偷，右孩子偷)
    // root[0] = Math.max(rob(root.left)[0], rob(root.left)[1]) +
    // Math.max(rob(root.right)[0], rob(root.right)[1])
    // 偷：左孩子不偷+ 右孩子不偷 + 当前节点偷
    // root[1] = rob(root.left)[0] + rob(root.right)[0] + root.val;

    public static int rob3(TreeNode root) {
        int[] res = robAction1(root);
        return Math.max(res[0], res[1]);
    }

    static int[] robAction1(TreeNode root) {
        logger.info("当前节点的值：{}",root==null?null:root.val);
        //1
        int res[] = new int[2];
        //2
        if (root == null) return res;
        //3
        int[] left = robAction1(root.left);
        logger.info("left数组：{}",Arrays.toString(left));
        //4
        int[] right = robAction1(root.right);
        logger.info("right数组：{}",Arrays.toString(right));
        //5
        res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
        //6
        res[1] = root.val + left[0] + right[0];
        //7
        logger.info("res数组：{}",Arrays.toString(res));
        return res;
    }

    public static void main(String[] args) {
        Integer[] array = {3,2,3,null,3,null,1};
        rob3(TreeUtil.createTree(array));
    }

```

### 121. 买卖股票的最佳时机

给定一个数组 prices ，它的第i个元素prices[i] 表示一支给定股票第 i 天的价格。你只能选择某一天买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

```java
public class MaxProfit {

    public int maxProfit(int[] prices){
        //默认初始时口袋中的钱为0
        //dp[i][0]:第i天持有股票，口袋中的钱为dp[i][0]
        //dp[i][1]:第i天不持有股票，口袋中的钱为dp[i][1]
        //dp[i][0] = Math.max(-prices[i],dp[i-1][0])
        //dp[i][1] = Math.max(prices[i]+dp[i-1][0],dp[i-1][1])

        if(prices == null || prices.length==0){
            return 0;
        }

        int length = prices.length;

        int[][] dp = new int[length][2];

        dp[0][0] = -prices[0];
        dp[0][1] = 0;

        for (int i = 1; i < length; i++) {
            dp[i][0] = Math.max(-prices[i],dp[i-1][0]);
            dp[i][1] = Math.max(prices[i]+dp[i-1][0],dp[i-1][1]);
        }
        return dp[length-1][1];
    }
    
}
```

### 122. 买卖股票的最佳时机Ⅱ

给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。在每一天，你可以决定是否购买和/或出售股票。你在任何时候最多只能持有一股股票。你也可以先购买，然后在 同一天 出售。返回你能获得的最大利润 。

```java
/**
 * @author yhli3
 * @ClassName MaxProfit2.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年04月22日 19:33:00
 */
public class MaxProfit2 {

    public int maxProfit(int[] prices){
        int n = prices.length;
        int[][] dp = new int[n][2];

        //dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]-prices[i])
        //dp[i][1] = Math.max(dp[i-1][1],prices[i]+dp[i-1][0])

        dp[0][0] = -prices[0];
        dp[0][1] = 0;

        for (int i = 1; i < n; i++) {
            dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]-prices[i]);
            dp[i][1] = Math.max(dp[i-1][1],prices[i]+dp[i-1][0]);
        }

        return dp[n-1][1];

    }

}

```

### 123. 买卖股票的最佳时机Ⅲ

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。**你最多可以完成两笔交易**。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

```java
 public int maxProfit(int[] prices){
        if(prices==null||prices.length==0){
            return 0;
        }
        /**
         * 初始时口袋中的钱为0
         * dp[i][j]:第i+1天，第j种状态时口袋中的现金为dp[i][j]
         * 五种状态：
         * 0：没有操作，1：第一次买入，2：第一次卖出，3：第二次买入，4：第二次卖出
         */
        int[][] dp = new int[prices.length][5];

        //初始化
        dp[0][1] = -prices[0];
        dp[0][2] = 0;
        dp[0][3] = -prices[0];
        dp[0][4] = 0;

        /**
         * 初始时现金为0，那么买入股票的时候，dp[i][1]或dp[i][3]一定为负数，计算利润的时候就不难理解为什么会出现prices[i]+dp[i-1][1]和prices[i]+dp[i-1][3]
         */
        for(int i = 1;i<prices.length;i++){
            /**
             * dp[i][1]可以分为两种情况：1.前一天（i-1）已经买入；2. 第i天才买入
             */
            dp[i][1] = Math.max(dp[i-1][1],-prices[i]);
            dp[i][2] = Math.max(dp[i-1][2],prices[i]+dp[i-1][1]);
            dp[i][3] = Math.max(dp[i-1][3],dp[i-1][2]-prices[i]);
            dp[i][4] = Math.max(dp[i-1][4],prices[i]+dp[i-1][3]);
        }
        return dp[prices.length-1][4];
    }
```

### 188. 买卖股票的最佳时机Ⅳ

给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

```java
    public int maxProfit(int k,int[] prices){
        if(prices==null||prices.length==0){
            return 0;
        }

        /**
         * 初始时口袋中的钱为0
         * dp[i][j]:第i+1天，第j种状态时口袋中的现金为dp[i][j]
         * 2k+1种状态：
         * 0：没有操作，1：第一次买入，2：第一次卖出，3：第二次买入，4：第二次卖出......
         */
        int[][] dp = new int[prices.length][2*k+1];

        //初始化


        for (int i = 1; i < 2*k; i+=2) {
            dp[0][i] = -prices[0];
        }

        /**
         * 初始时现金为0，那么买入股票的时候，dp[i][1]或dp[i][3]一定为负数，计算利润的时候就不难理解为什么会出现prices[i]+dp[i-1][1]和prices[i]+dp[i-1][3]
         * dp[i][1]可以分为两种情况：1.前一天（i-1）已经买入；2. 第i天才买入
         */
        for(int i = 1;i<prices.length;i++){
            for (int j =1;j<=2*k;j+=2){
                dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-1]-prices[i]);
                dp[i][j+1] = Math.max(dp[i-1][j+1],prices[i]+dp[i-1][j]);
            }
            //dp[i][1] = Math.max(dp[i-1][1],-prices[i]);
            //dp[i][2] = Math.max(dp[i-1][2],prices[i]+dp[i-1][1]);
            //dp[i][3] = Math.max(dp[i-1][3],dp[i-1][2]-prices[i]);
            //dp[i][4] = Math.max(dp[i-1][4],prices[i]+dp[i-1][3]);
        }
        return dp[prices.length-1][2*k];
    }
```

### 309. 最佳买卖股票时机含冷冻期

给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。​设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）：卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）

```java
    /**
     * 分为四种状态：
     * 0. 买入股票状态（今天买入或者之前就买入了）
     * 1. 两天前就卖出股票了，度过了冷冻期，一直没有操作，今天保持卖出股票状态
     * 2. 今天卖出股票
     * 3. 冷冻期状态
     * @param prices
     * @return
     */
    public int maxProfit(int[] prices){

        if(prices==null||prices.length<2){
            return 0;
        }

        int[][] dp = new int[prices.length][4];
        dp[0][0] = -prices[0];
        for (int i = 1; i < prices.length; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], Math.max(dp[i - 1][3], dp[i - 1][1]) - prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][3]);
            dp[i][2] = dp[i - 1][0] + prices[i];
            dp[i][3] = dp[i - 1][2];
        }
        
        return Math.max(dp[prices.length-1][3],Math.max(dp[prices.length-1][1], dp[prices.length-1][2]));

    }
```

### 714. 买卖股票的最佳时机含手续费

给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最大值。注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

```java
public int maxProfit(int[] prices, int fee){

        //默认初始时口袋中的钱为0
        //dp[i][0]:第i天持有股票状态，口袋中的钱为dp[i][0]
        //dp[i][1]:第i天不持有股票状态，口袋中的钱为dp[i][1]

        //dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]-prices[i])
        //dp[i][1] = Math.max(dp[i-1][1],prices[i]+dp[i-1][0])
        int n = prices.length;
        int[][] dp = new int[n][2];

        //初始化
        dp[0][0] = -prices[0];
        dp[0][1] = 0;

        for (int i = 1; i < n; i++) {
            dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]-prices[i]);
            //和买卖股票的最佳时机Ⅱ的区别是多减了一个fee
            dp[i][1] = Math.max(dp[i-1][1],prices[i]+dp[i-1][0]-fee);
        }

        return dp[n-1][1];
    }
```


---
title: 代码随想录刷题笔记
date: 2022-2-28
tags: 
- 代码随想录
categories:
- Algorithm
# sticky: 1
---

## 数组

### 1. 二分查找

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

```java
//适用于target定义在左闭右闭的区间，即[left,right]
class Solution {
    public int search(int[] nums, int target) {
        int left =0;
        int right = nums.length-1;
        int middle;
        //如果target不在数组内部，提前做判断返回，减少后面的循环次数
        if(target<nums[0]||target>nums[nums.length-1]){
            return -1;
        }
        //注意是left<=right
        while(left<=right){
            middle = left+(right-left)/2;
            if(target==nums[middle]){
                return middle;
            }else if(target<nums[middle]){
                //如果写成right=middle，还可以进一步优化，因为target一定不等于nums[middle]，所以right=middle-1
                right=middle-1;
            }else{
                left=middle+1;
            }
        }
        return -1;
    }
}
//适用于target定义在左闭右开的区间，即[left,right)
class Solution {
    public int search(int[] nums, int target) {
        int left = 0, right = nums.length;
        //注意是left<right
        while (left < right) {
            int mid = left + ((right - left) >> 1);
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] < target)
                left = mid + 1;
            else if (nums[mid] > target)
                //注意是r
                right = mid;
        }
        return -1;
    }
}
```

### 2. 移除元素

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

```java
//暴力解法
class Solution {
    public int removeElement(int[] nums, int val) {
        int length = nums.length;
        for(int i=0;i<length;i++){     
            if(val==nums[i]){
                for(int j=i+1;j<length;j++){
                    nums[j-1]=nums[j];
                }
                i--;
                length--;
            }
        }
        return length;
    }
}
//双指针
class Solution {
    public int removeElement(int[] nums, int val) {
        int fast=0;
        int slow;
        for(slow=0;fast<nums.length;fast++){
            if(nums[fast]!=val){
                nums[slow]=nums[fast];
                slow++;
            }
        }
        return slow;
    }
}
```

### 3. 有序数组的平方

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

```java
class Solution {
    //双指针解法
    public int[] sortedSquares(int[] nums) {
        int left = 0;
        int right =nums.length-1;
        int[] res = new int[nums.length];
        int p = res.length-1;
        while(left<=right){
            if(nums[left]*nums[left]>nums[right]*nums[right]){
                res[p--]=nums[left]*nums[left];
                left++;
            }else{
                res[p--]=nums[right]*nums[right];
                right--;
            }
        }
        return res;
    }
}
时间复杂度：O(n)
空间复杂度：O(1)（不算存储数组z）或者O(n)都没问题
```

### 4. 长度最小的子数组

给定一个含有 n 个正整数的数组和一个正整数 target 。找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

```java
//滑动窗口
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        //滑动窗口和双指针类似
        //左指针
        int l=0;
        //初始化返回的结果
        int res = Integer.MAX_VALUE;
        //sum用于计算滑动窗口元素的和
        int sum=0;
        for(int r=0;r<nums.length;r++){
            sum+=nums[r];
            //判断滑动窗口的值是否大于target
            while(sum>=target){
                //计算符合条件的最小的滑动窗口大小
                res=Math.min(r-l+1,res);
                //左指针右移，缩小滑动窗口
                sum-=nums[l++];
            }
        }
        return res==Integer.MAX_VALUE?0:res;
    }
}

//暴力解法
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int res=0;
        int min=Integer.MAX_VALUE;
        Set<Integer> set = new HashSet<>();
        for(int i=0;i<nums.length;i++){
            res=nums[i];
            for(int j=i+1;j<nums.length;j++){
                if(res>=target){
                    return 1;
                }
                res+=nums[j];
                if(res>=target){
                    set.add(j-i+1);
                    break;
                }
            }  
        }
        if(nums[nums.length-1]==target){
            set.add(1);
        }
        if(set.isEmpty()){
            return 0;
        }
        for(Integer e:set){
            min=Math.min(e,min);
        }
        return min;
    }
}
```

### 5. 螺旋矩阵Ⅱ

给你一个正整数 n ，生成一个包含 1 到 n² 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。

![螺旋矩阵Ⅱ-2022-04-19-21-27-40](https://imagecontainter-1309978559.cos.ap-chengdu.myqcloud.com/blogimages/螺旋矩阵Ⅱ-2022-04-19-21-27-40.png)

![test-2022-04-19-21-47-23](www.yhli.work/blogimages/test-2022-04-19-21-47-23.png)

```java
    public stati int[][] generateMatrix(int n) {
        if(n==1) return new int[][]{{1}};
        int[][] res = new int[n][n];
        int l=0;
        int r=n-1;
        int t=0;
        int b=n-1;
        //count用来计数
        int count =1;
        int mid = n/2;
        while(true){
            //1.模拟从左向右
            for(int i=t;i<r;i++){
                res[t][i]=count++;
            }
            //上边界向内缩进一格
            if(++t>b) break;
            //2.模拟从上到下
            for(int i=l;i<b;i++){
                res[i][r]=count++;
            }
            //右边界向内缩进一格
            if(--r<l) break;
            //3.模拟从右到左
            for(int i= r+1;i>l;i--){
                res[b][i]=count++;
            }
            //下边界向内缩进一格
            //if(--b<t) break;当n=2时会出错
            if(b--<t) break;
            //4.模拟从下到上
            for(int i=b+1;i>=t;i--){
                res[i][l]=count++;
            }
            //左边界向内缩进一格
            if(++l>r) break;
        }
        if(n%2==1){
            //n为奇数，上面while中的算法会导致矩阵中心为0，因此需要手动给矩阵中心赋值
            res[mid][mid]=count;
        }
        return res;
    }
```

## 链表

### 203. 移除链表元素

给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回新的头节点 。

```java
public class ListNode{
    int val;
    ListNode next;
    ListNose(){}
    ListNode(int val){this.val=val;}
    ListNode(int val,ListNode next){this.val=val;this.next=next;}
}
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode dummy = new ListNode(0,head);
        //关键：初始时pre和dummy管理的是同一个结点
        ListNode pre = dummy;
        ListNode cur = head;
        while(cur!=null){
            if(cur.val==val){
                pre.next=cur.next;
            }else{
                pre=cur;
            }
            cur=cur.next;
        }
        return dummy.next;
    }
}
```

### 707. 设计链表的实现

您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。在链表类中实现这些功能：
get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。
addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。
addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。
addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。
deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。

```java
//自己定义一个单链表类
class ListNode{
    int val;
    ListNode next;
    ListNode(){};
    ListNode(int val){
        this.val=val;
    }
    ListNode(int val,ListNode next){
        this.val=val;
        this.next=next;
    }
}
class MyLinkedList {
    //size存储链表元素个数
    int size;
    ListNode head;
    //初始化链表
    public MyLinkedList() {
        size=0;
        head=new ListNode(0);
    }
    
    public int get(int index) {
        if(index<0||index>=size){
            return -1;
        }
        ListNode cur = head;
        for(int i=0;i<=index;i++){
            cur=cur.next;
        }
        return cur.val;
    }
    
    public void addAtHead(int val) {
        addAtIndex(0,val);
    }
    
    public void addAtTail(int val) {
        addAtIndex(size,val);
    }
 
    public void addAtIndex(int index, int val) {
        //index大于链表的长度
        if(index>size){
            return;
        }
        //index小于0
        if(index<0){
            index=0;
        }
        size++;
        //0=<index长度<=链表长度
        //找到要插入结点的前驱结点
        ListNode pre = head;
        for(int i=0;i<index;i++){
            pre=pre.next;
        }
        ListNode toAdd = new ListNode(val);
        toAdd.next = pre.next;
        pre.next=toAdd;
    }

    public void deleteAtIndex(int index) {
        //判断索引是否有效
        if(index<0||index>=size){
            return;
        }
        //找到要删除结点的前驱结点
        ListNode pre = head;
        for(int i=0;i<index;i++){
            pre=pre.next;
        }
        pre.next=pre.next.next;
        size--;
    }

}

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList obj = new MyLinkedList();
 * int param_1 = obj.get(index);
 * obj.addAtHead(val);
 * obj.addAtTail(val);
 * obj.addAtIndex(index,val);
 * obj.deleteAtIndex(index);
 */
```

### 206. 反转链表

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
         ListNode pre = null;
         ListNode temp =null;
         ListNode cur = head;
         while(cur!=null){
             temp=cur.next;
             cur.next=pre;
             pre=cur;
             cur=temp;
         }
         return pre;
    }
}
```

### 24. 两两交换链表中的结点

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummy = new ListNode(0,head);
        ListNode pre =dummy;
        while(pre.next!=null&&pre.next.next!=null){
            ListNode temp = head.next.next;
            pre.next=head.next;
            //注意理解head.next.next代表的含义
            head.next.next=head;
            head.next=temp;
            pre=head;
            head=head.next;
        }
        return dummy.next;
    }
}
```

### 19. 删除链表的倒数第N个结点

给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

```java
//思路：先求出链表的长度len，如果len=n,说明要删除的是头节点，此时需要创建一个辅助虚拟节点；其它情况是遍历找到要删除节点的前驱结点pre，然后pre.next=pre.next.next
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        int len =0;
        ListNode cur =head;
        ListNode dummy = new ListNode(0,head);
        while(head!=null){
            len++;
            head=head.next;
        }
        if(n==len){
            dummy.next=cur.next;
            return dummy.next;
        }
        for(int i=0;i<len-n-1;i++){
            cur=cur.next;
        }
        cur.next=cur.next.next;
        return dummy.next;
    }
}
//另一个思路，使用双指针，初始时slow和fast指针指向head头节点，然后将fast指针向前移动n个位置，最后同步移动slow和fast指针，fast指针指向null时，slow指针z
```

### 面试题02.07.链表相交

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。

```java
// public class ListNode{
//     int val;
//     ListNode next;
//     public ListNode(){}
//     public ListNode(int val){
//         this.val=val;
//     }
//     public ListNode(int val,ListNode next){
//         this.val=val;
//         this.next=next;
//     }
// }
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode curA = headA;
        ListNode curB = headB;
        int lenA=0;
        int lenB=0;
        //计算头节点为headA的链表的长度
        while(headA!=null){
            lenA++;
            headA=headA.next;
        }
         //计算头节点为headB的链表的长度
        while(headB!=null){
            lenB++;
            headB=headB.next;
        }
        if(lenA>=lenB){
            for(int i=0;i<lenA-lenB;i++){
                curA=curA.next;
            }
            while(curA!=curB){
                curB=curB.next;
                curA=curA.next;
            }
            return curA;
        }else{
            for(int i=0;i<lenB-lenA;i++){
                curB=curB.next;
            }
            while(curA!=curB){
                curB=curB.next;
                curA=curA.next;
            }
            return curA;
        }
    }
}
```

### 142. 环形链表Ⅱ

给定一个链表的头节点head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。不允许修改链表。

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        ListNode p1 = head;
        ListNode p2 =head;
        while(fast!=null&&fast.next!=null){
            fast=fast.next.next;
            slow=slow.next;
            if(fast==slow){
                p2=fast;
                while(p1!=p2){
                    p1=p1.next;
                    p2=p2.next;
                }
                return p1;
            }
        }
        return null;
    }
}
//备注：也可以采用哈希表，如果遇到重复的一定有h
```

## 哈希表

### 242. 有效的字母异位词

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。

```java
public class IsAnagram {
    public boolean isAnagram(String s, String t) {
        //k存的是字符，v存的是字符出现的次数
        Map<Character,Integer> maps = new HashMap<>();
        Map<Character,Integer> mapt = new HashMap<>();
        for(int i=0;i<s.length();i++){
            maps.put(s.charAt(i),maps.getOrDefault(s.charAt(i),0)+1);
        }
        for(int i=0;i<t.length();i++){
            mapt.put(t.charAt(i),mapt.getOrDefault(t.charAt(i),0)+1);
        }
        for(Character e:maps.keySet()){
            if(mapt.containsKey(e)){
                //if(maps.get(e)!=mapt.get(e))，会报错，包装器类之间的比较要用equals
                if(!maps.get(e).equals(mapt.get(e))){
                    return false;
                }
            }else{
                return false;
            }
        }
        return maps.size()!=mapt.size()?false:true;
    }
}
```

### 349. 两个数组的交集

给定两个数组 `nums1` 和 `nums2` ，返回 *它们的交集* 。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        Set<Integer> set1 = new HashSet<>();
        Set<Integer> resSet = new HashSet<>();
        for (int i : nums1) {
            set1.add(i);
        }
        for (int i : nums2) {
            if(set1.contains(i)){
                resSet.add(i);
            }
        }
        int[] res = new int[resSet.size()];
        int index = 0;
        for (Integer e : resSet) {
            //自动拆箱
            res[index++]=e;
        }
        return res;
    }
}
```

### 202. 快乐数

编写一个算法来判断一个数 n 是不是快乐数。「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果可以变为  1，那么这个数就是快乐数。如果 n 是快乐数就返回 True ；不是，则返回 False 。

```java
class Solution {
    
    public int sum(int n){
        int res=0;
        while(n!=0){
            int mod = n%10;
            n/=10;
            res+=mod*mod;
        }
        return res;
    }
    public boolean isHappy(int n) {
        HashSet<Integer> set = new HashSet<>();
        while(n!=1&&!set.contains(n)){
            set.add(n);
            n=sum(n);
        }
        return n==1;
    }
}
```

### 1. 两数之和

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

```java
class Solution {
 public int[] twoSum(int[] nums,int target){
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            if(map.containsKey(target-nums[i])){
                return new int[]{i,map.get(target-nums[i])};
            }
            map.put(nums[i],i);
        }
        return new int[]{};
    }
}
```

### 454. 四数相加Ⅱ

给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：

```math
(1)0 <= i, j, k, l < n;
(2)nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0
```

```java
/**四数相加
 * @author yhli3
 * @ClassName FourSumCount.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.哈希表
 * @createTime 2022年03月22日 18:51:00
 */
public class FourSumCount {
    public int fourSumCount(int[] nums1,int[] nums2,int[] nums3,int[] nums4){
        HashMap<Integer,Integer> map = new HashMap<>();
        //令nums1[i]+nums2[j]=a+b，map中的key存a+b的和，value存a+b的和出现的次数
        int n = nums1.length;
        int temp = 0;
        int count = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                temp=nums1[i]+nums2[j];
                map.put(temp,map.getOrDefault(temp,0)+1);
            }
        }
        //令nums3[k]+nums4[l]=c+d，如果map中包含-(c+d)，那么count=count+value
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                temp = nums3[i]+nums4[j];
                if(map.containsKey(-temp)){
                    count+=map.get(-temp);
                }
            }
        }
        return count;
    }
}
```

### 383. 赎金信

给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。如果可以，返回 true ；否则返回 false 。magazine 中的每个字符只能在 ransomNote 中使用一次。

使用hashmap(T(n)=o(n)，S(n)=o(n))

```java
    public boolean canConstruct(String ransomNote,String magazine){
        HashMap<Character,Integer> map = new HashMap<>();
        for (int i = 0; i < magazine.length(); i++) {
            map.put(magazine.charAt(i),map.getOrDefault(magazine.charAt(i),0)+1);
        }
        for (int i = 0; i < ransomNote.length(); i++) {
            if (!map.containsKey(ransomNote.charAt(i))){
                return false;
            }else {
                if (map.get(ransomNote.charAt(i))==0){
                    return false;
                }
                map.put(ransomNote.charAt(i),map.getOrDefault(ransomNote.charAt(i),0)-1);
            }
        }
        return true;
    }
```

使用数组(T(n)=o(n)，S(n)=o(1))：

```java
    //前置知识：①字符a,b,c....z的ASCII值从97开始依次递增至122；②两个字符做运算本质是他们的ASCII值做运算
    public boolean canConstruct(String ransomNote,String magazine){
        int[] arr = new int[26];
        for (int i = 0; i < magazine.length(); i++) {
            arr[magazine.charAt(i)-'a'] +=1;
        }
        for (int i = 0; i < ransomNote.length(); i++) {
            if (arr[ransomNote.charAt(i)-'a']<=0){
                return false;
            }
            arr[ransomNote.charAt(i)-'a']-=1;
        }
        return true;
    }
```

### 15. 三数之和

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。注意：答案中不可以包含重复的三元组。

```java
public class ThreeSum {
    /**
     * 大致思路：对数组排序，使用2个指针b=a+1,c=nums.length-1（其中a为遍历nums数组for循环中的i），如果nums[a]+nums[b]+nums[c]<0，则移动b指针；如果nums[a]+nums[b]+nums[c]>0，则移动c指针；如果nums[a]+nums[b]+nums[c]==0，把结果存入res中。
     * @param nums
     * @return
     */
    public List<List<Integer>> threeSum(int[] nums){
        List<List<Integer>> res = new ArrayList<>();
        Arrays.sort(nums);
        int b,c = 0;
        for (int a = 0; a < nums.length; a++) {
            //if (nums.length-a<=2){
            //    break;
            //}
            if(nums[a]>0){
                return res;
            }
            if(a>0&&nums[a]==nums[a-1]){
                continue;
            }
            b = a+1;
            c = nums.length-1;
            while (b<c){
                if(nums[a]+nums[b]+nums[c]<0){
                    b++;
                }else if (nums[a]+nums[b]+nums[c]>0){
                    c--;
                }else {
                    //优化为使用Arrays.asList
                    //ArrayList<Integer> list = new ArrayList<>();
                    //list.add(nums[a]);
                    //list.add(nums[b]);
                    //list.add(nums[c]);
                    //res.add(list);
                    res.add(Arrays.asList(nums[a],nums[b],nums[c]));
                    //下面的代码不好想
                    while (b<c&&nums[b]==nums[b+1]) {
                        b++;
                    }
                    while (c>b&&nums[c]==nums[c-1]) {
                        c--;
                    }
                    b++;//没想到
                    c--;//没想到
                }
            }
        }
        return res;
    }
}
```

### 18. 四数之和

给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：

```java
①0 <= a, b, c, d < n
②a、b、c 和 d 互不相同
③nums[a] + nums[b] + nums[c] + nums[d] == target
```

你可以按 任意顺序 返回答案 。

```java
public class FourSum {
    /**
     * 双指针
     * @param nums
     * @param target
     * @return
     */
    public List<List<Integer>> fourSum(int[] nums,int target){
        List<List<Integer>> res = new ArrayList<>();
        Arrays.sort(nums);
        for (int i = 0; i < nums.length; i++) {
            //剪枝防止{1000000000,1000000000,1000000000,1000000000}导致溢出
            if (nums[i]>target&&(nums[i]>0||target>0)||nums.length-i<4){
                break;
            }
            //nums[i]之后取得到的和nums[i-1]都可以取得到
            if (i>0&&nums[i]==nums[i-1]){
                continue;
            }
            for (int j = i+1; j < nums.length; j++) {
                if (j>i+1&&nums[j]==nums[j-1]){
                    continue;
                }
                int left = j+1;
                int right = nums.length-1;
                while (left<right){
                    //long sum = (nums[i] + nums[j] + nums[left] + nums[right]);//声明为long类型可以防止溢出
                    if (nums[i]+nums[j]+nums[left]+nums[right]<target){
                        left++;
                    }else if (nums[i]+nums[j]+nums[left]+nums[right]>target){
                        right--;
                    }else {
                        res.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right]));
                        while (right>left&&nums[right]==nums[right-1]){
                            right--;
                        }
                        while (left<right&&nums[left]==nums[left+1]){
                            left++;
                        }
                        left++;
                        right--;
                    }
                }
            }
        }
        return res;
    }
}
```

## 字符串

### 541. 反转字符串Ⅱ

给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。
如果剩余字符少于 k 个，则将剩余字符全部反转。
如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。

```java
public class ReverseStr {
    public String reverseStr(String s,int k){
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < s.length(); i+=2*k) {
            if(s.length()-i<k){
                reverseHelper(i,s.length()-1,sb,s);
                break;
            }else if (s.length()-i<2*k&&s.length()-i>=k){
                reverseHelper(i,i+k-1,sb,s);
                //添加未反转的字符
                for (int j = i+k;j<s.length();j++){
                    sb.append(s.charAt(j));
                }
                break;
            }
            reverseHelper(i,i+k-1,sb,s);
            //添加后k个字符
            for (int j = i+k;j<i+2*k;j++){
                sb.append(s.charAt(j));
            }
        }
        return sb.toString();
    }

    //反转前k个字符
    public void reverseHelper(int a ,int b,StringBuilder sb,String s){
        for(int j = b;j>=a;j--){
            sb.append(s.charAt(j));
        }
    }

}
```

## 双指针

### 27. 移除元素

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

```java
public class RemoveElement {
    public int removeElement(int[] nums,int val){
        //快指针：用于寻找新数组元素
        //int fast = 0;
        //慢指针：新数组元素的下标
        int slow = 0;
        for (int fast = 0; fast < nums.length; fast++) {
            if(nums[fast]!=val){
                nums[slow] = nums[fast];
                slow++;
            }
        }
        return slow;
    }
}
```

### 344. 反转字符串

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

```java
public class ReverseString {
    public void reverseString(char[] s){
        int left = 0;
        int right = s.length-1;
        while (left<right){
            char temp = ' ';
            temp = s[left];
            s[left] = s[right];
            s[right] = temp;
            left++;
            right--;
        }
    }
}
```

### 剑指offer05. 替换空格

请实现一个函数，把字符串 s 中的每个空格替换成"%20"。

```java
public class ReplaceSpace {
    public String replaceSpace(String s){
        //StringBuilder线程不安全
        //StringBuffer线程安全
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (c==' '){
                sb.append("%20");
            }else {
                sb.append(c);
            }
        }
        return sb.toString();
    }
}
```

### 151. 颠倒字符串中的单词

给你一个字符串 s ，颠倒字符串中 单词 的顺序。单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。

```java
public class ReverseWords {
    //将字符串转化为字符数组来处理，避免使用字符串的trim()、split()等库函数
    public String reverseWords(String s){
        char[] oldArr = s.toCharArray();
        char[] newArr = new char[oldArr.length+1];
        int newIndex = 0;
        int p = oldArr.length-1;
        while (p>=0){
            while (p>=0&&oldArr[p]==' '){
                p--;
            }
            int temp = p;
            while (p>=0&&oldArr[p]!=' '){
                p--;
            }
            for (int i =p+1;i<=temp;i++){
                newArr[newIndex++] = oldArr[i];
                if(i==temp){
                    newArr[newIndex++] = ' ';
                }
            }
        }
        return new String(newArr,0,newIndex-1);
    }
}
```

### 剑指Offer 58-Ⅱ. 左旋转字符串

字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。

```java
public class ReverseLeftWords {
    public String reverseLeftWords(String s,int n){
        StringBuilder sb = new StringBuilder();
        for (int i = n; i < s.length(); i++) {
            sb.append(s.charAt(i));
        }
        for (int i = 0;i<n;i++){
            sb.append(s.charAt(i));
        }
        return sb.toString();
    }
}
```

### 28. 实现strStr()

实现 strStr() 函数。

给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。说明：当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java的indexOf() 定义相符。

```java
    public int strStr(String haystack,String needle){
        if(needle.equals("")){
            return 0;
        }
        if(needle.length()>haystack.length()){
            return -1;
        }
        int j = 0;
        int index = 0;
        Queue<Integer> queue = new LinkedList<>();
        //遍历，找出haystack中和needle首字符相同的字符，并把该字符的下标存在一个队列queue中
        for (int i = 0; i < haystack.length(); i++) {
            if(haystack.charAt(i)==needle.charAt(0)){
                queue.add(i);
            }
        }
        while (queue.size()>0){
            j = queue.remove();
            //如果haystack中剩余字符串的长度比needle小，提前返回-1
            if(haystack.length()-j<needle.length()){
                return -1;
            }
            //从队列中取出元素，把字符串haystack和needle逐一进行比对
            for (int i = j; i < haystack.length(); i++) {
                if(haystack.charAt(i)==needle.charAt(index)){
                    if(i-j+1==needle.length()){
                        return j;
                    }
                    index++;
                }else {
                    index=0;
                    break;
                }
            }
        }
        return -1;
    }
```

### 459. 重复的子字符串

```java
public class RepeatedSubstringPattern {
    public boolean repeatedSubstringPattern(String s){
        int length = s.length();
        boolean flag = false;
        //枚举重复子串的长度i，如果存在重复子串，那么i的大小必小于等于二分之一字符串s的长度
        for (int i = 1; i <= s.length()/2; i++) {
            //如果存在重复子串，那么i必为字符串s长度的因数，即length%i必为0
            if(length%i==0){
                flag = true;
                for (int j = i;j<length;j++){
                    if(s.charAt(j)!=s.charAt(j-i)){
                        flag = false;
                        break;
                    }
                }
                if(flag){
                    return true;
                }
            }
        }
        return flag;
    }
}
```

## 栈与队列

### 232. 用栈实现队列

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：

实现 MyQueue 类：

- void push(int x) 将元素 x 推到队列的末尾
- int pop() 从队列的开头移除并返回元素
- int peek() 返回队列开头的元素
- boolean empty() 如果队列为空，返回 true ；否则，返回 false
说明：

- 你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
- 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。

```java
public class MyQueue {
    /**
     * 输入栈
     */
    Stack<Integer> inputStack;
    /**
     * 输出栈
     */
    Stack<Integer> outputStack;

    public MyQueue(){
        inputStack = new Stack<>();
        outputStack = new Stack<>();
    }

    public void push(int x){
        inputStack.push(x);
    }

    public int pop(){
        dumpToOutputStack();
        return outputStack.pop();
    }

    public int peek(){
        dumpToOutputStack();
        return outputStack.peek();
    }

    public boolean empty(){
        return inputStack.empty()&& outputStack.empty();
    }

    /**
     * 在执行pop()或者peek()时，如果outputStack输出栈中的元素为空，将输入栈中的元素全部弹出，放进输出栈中
     */
    public void dumpToOutputStack(){
        if(!outputStack.empty()){
            return;
        }
        while (!inputStack.empty()){
            outputStack.push(inputStack.pop());
        }
    }
    
}
```

### 225. 用队列实现栈

请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。实现 MyStack 类：

- void push(int x) 将元素 x 压入栈顶。
- int pop() 移除并返回栈顶元素。
- int top() 返回栈顶元素。
- boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。

双队列版本：

```java
//top()或者pop()操作时，把queue1中除去最后一个入队的元素以外的所有元素加入到queue2中，然后再把queue2中的元素重新加入到queue1中
public class MyStack {

    Queue<Integer> queue1;
    Queue<Integer> queue2;//备份

    public MyStack() {
       queue1 = new LinkedList();
       queue2 = new LinkedList();
    }

    public void push(int x) {
        queue1.add(x);
    }

    public int pop() {
        while (queue1.size()>1){
            queue2.add(queue1.remove());
        }
        Integer remove = queue1.remove();
        while (!queue2.isEmpty()){
            queue1.add(queue2.remove());
        }
        return remove;
    }

    public int top() {
        while (queue1.size()>1){
            queue2.add(queue1.remove());
        }
        Integer peek = queue1.remove();
        while (!queue2.isEmpty()){
            queue1.add(queue2.remove());
        }
        queue1.add(peek);
        return peek;
    }

    public boolean empty() {
        return queue1.isEmpty();
    }

}
```

双队列版本1优化

```java
public class MyStack {

    Queue<Integer> queue1;//模拟栈
    Queue<Integer> queue2;//备份

    public MyStack() {
       queue1 = new LinkedList();
       queue2 = new LinkedList();
    }

    public void push(int x) {
        queue2.add(x);
        while (!queue1.isEmpty()){
            queue2.add(queue1.remove());
        }
        //交换queue1和queue2
        Queue<Integer> tempQueue;
        tempQueue = queue2;
        queue2 = queue1;
        queue1 = tempQueue;
    }

    public int pop() {
        return queue1.remove();
    }

    public int top() {
       return queue1.peek();
    }

    public boolean empty() {
        return queue1.isEmpty();
    }

}
```

双端队列Deque实现

```java
public class MyStack {

    Deque<Integer> queue;

    public MyStack() {
       queue = new LinkedList();
    }

    public void push(int x) {
        queue.addFirst(x);
    }

    public int pop() {
        return queue.removeFirst();
    }

    public int top() {
        return queue.peekFirst();
    }

    public boolean empty() {
        return queue.isEmpty();
    }
    
}

```

单项队列实现

```java
//top()或者pop()操作时将队列中除最后一个元素以外的其它元素移除，并重新加入队列
public class MyStack {

    Queue<Integer> queue;

    public MyStack() {
       queue = new LinkedList();
    }

    public void push(int x) {
        queue.add(x);
    }

    public int pop() {
        for (int i = 0; i < queue.size()-1; i++) {
            queue.add(queue.remove());
        }
        return queue.remove();
    }

    public int top() {
        for (int i = 0; i < queue.size()-1; i++) {
            queue.add(queue.remove());
        }
        Integer peek = queue.remove();
        queue.add(peek);
        return peek;
    }

    public boolean empty() {
        return queue.isEmpty();
    }

}
```

### 20. 有效的括号

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。有效字符串需满足：

- 左括号必须用相同类型的右括号闭合。
- 左括号必须以正确的顺序闭合。

```java
public class IsValid {
    public boolean isValid(String s){
        Stack<Character> stack = new Stack<>();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            //如果遇到左括号就把配对的右括号压入栈中
            if(c=='('){
                stack.push(')');
            }else if (c=='['){
                stack.push(']');
            }else if (c=='{'){
                stack.push('}');
            }else  if (stack.isEmpty()||c!=stack.peek()){//(c!=stack.peek()||stack.isEmpty())这样写，如果输入的s为']'会报错
                return false;
            }else {
                stack.pop();
            }
        }
        return stack.isEmpty();
    }
}
```

### 1047. 删除字符串中的所有相邻重复项

给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。在 S 上反复执行重复项删除操作，直到无法继续删除。在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

版本1：

```java
public class RemoveDuplicates {
    public String removeDuplicates(String s){
        Stack<Character> stack = new Stack<>();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (stack.isEmpty()||stack.peek()!=c){
                stack.push(c);
            }else {
               stack.pop();
            }
        }
        char[] res = new char[stack.size()];
        for (int i = stack.size()-1; i >= 0; i--) {
            res[i] = stack.pop();
        }
        return new String(res);
    }
}
```

版本2：

```java
public class RemoveDuplicates {
    public String removeDuplicates(String s){
        Stack<Character> stack = new Stack<>();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (stack.isEmpty()||stack.peek()!=c){
                stack.push(c);
            }else {
               stack.pop();
            }
        }
        //'a'+""可以把字符'a'变成字符串"a"
        String res = "";
        int size = stack.size();
        for (int i = 0; i < size; i++) {
            res = stack.pop()+res;
        }
        return res;
    }
}
```

### 150. 逆波兰表达式求值

根据逆波兰表示法，求表达式的值。有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。注意两个整数之间的除法只保留整数部分。可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。

版本1：

```java
public class EvalRPN {
    public int evalRPN(String[] tokens){
        Deque<String> stack = new ArrayDeque<>();
        for (String s : tokens) {
            if(s.equals("+")){//使用s=="+"会报错
                stack.push(Integer.parseInt(stack.pop())+Integer.parseInt(stack.pop())+"");
            }else if (s.equals("-")){
                String num1 = stack.pop();
                String num2 = stack.pop();
                stack.push(Integer.parseInt(num2)-Integer.parseInt(num1)+"");
            }else if (s.equals("*")){
                String num1 = stack.pop();
                String num2 = stack.pop();
                stack.push(Integer.parseInt(num2)*Integer.parseInt(num1)+"");
            }else if (s.equals("/")){
                String num1 = stack.pop();
                String num2 = stack.pop();
                stack.push(Integer.parseInt(num2)/Integer.parseInt(num1)+"");
            }else {
                stack.push(s);
            }
        }
        return Integer.parseInt(stack.pop());
    }
}
```

版本2：stack中直接存入字符串s对应的Integer值

```java
public class EvalRPN {
    public int evalRPN(String[] tokens){
        Deque<Integer> stack = new ArrayDeque<>();
        for (String s : tokens) {
            if(s.equals("+")){
                stack.push(stack.pop()+stack.pop());
            }else if (s.equals("-")){
                stack.push(-stack.pop()+stack.pop());
            }else if (s.equals("*")){
                stack.push(stack.pop()*stack.pop());
            }else if (s.equals("/")){
                Integer a = stack.pop();
                Integer b = stack.pop();
                stack.push(b/a);
            }else {
                stack.push(Integer.valueOf(s));
            }
        }
        return stack.pop();
    }
}
```

### 239. 滑动窗口的最大值

给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。返回 滑动窗口中的最大值 。

```java
public class MaxSlidingWindow {
    public int[] maxSlidingWindow(int[] nums,int k){
        //队列中存放的是元素的下标
        Deque<Integer> deque = new ArrayDeque<>();
        //存放结果的数组
        int[] res = new int[nums.length-k+1];
        int index = 0;
        //闭区间[x,i]中的元素个数：i-x+1
        //滑动窗口：[i+1-k,i]
        for (int i = 0; i < nums.length; i++) {
            //如果队列头中的下标不在滑动窗口[i+1-k,i]中，则弹出队列头元素
            while (!deque.isEmpty()&&deque.peek()<i+1-k){
                deque.pop();
            }
            //队列非空且队列的尾部元素比待加入的元素小，则弹出队列尾部元素，保证队列是单调的
            while (!deque.isEmpty()&&nums[deque.peekLast()]<nums[i]){
                deque.pollLast();
            }
            deque.add(i);
            if(i>=k-1){
                res[index++] = nums[deque.peek()];
            }
        }
        return res;
    }
}
```

### 347. 前K个高频元素

给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。

```java
public class TopKFrequent {
    /**
     * priorityqueue底层采用的是堆（一颗完全二叉树），默认是最小堆，即priorityqueue的头部元素是最小的，priorityqueue.remove()会移除最小的元素
     * @param nums
     * @param k
     * @return
     */
    public int[] topKFrequent(int[] nums,int k){
        //key为元素，value为元素出现的次数
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            map.put(nums[i],map.getOrDefault(nums[i],0)+1);
        }
        Set<Map.Entry<Integer, Integer>> entries = map.entrySet();
        //Map.Entry<Integer,Integer>是一个接口
        //(o1,o2)->o1.getValue()- o2.getValue()自定义的Comparator，队列中的头元素是value值最小的键值对entry
        //(o1,o2)->o2.getValue()- o1.getValue()自定义的Comparator，队列中的头元素是value值最大的键值对entry
        PriorityQueue<Map.Entry<Integer,Integer>> priorityQueue = new PriorityQueue<>((o1,o2)->o1.getValue()- o2.getValue());
        for (Map.Entry<Integer, Integer> entry : entries) {
            priorityQueue.offer(entry);
            if(priorityQueue.size()>k){
                //移除优先队列头部元素
                priorityQueue.remove();
            }
        }
        //存放结果的数组
        int[] res = new int[k];
        int size = priorityQueue.size();
        for (int i = 0; i < size; i++) {
            res[i] = priorityQueue.remove().getKey();
        }
        return res;
    }

    //测试
    public static void main(String[] args) {
        int[] arr = {1,1,1,2,2,3};
        int[] arr = {1,1,1,2,2,3};
        int k = 2;
        TopKFrequent frequent = new TopKFrequent();
        frequent.topKFrequent(arr,k);
        PriorityQueue<Integer> priorityQueue = new PriorityQueue<>();//默认小顶堆
        priorityQueue.add(5);
        priorityQueue.add(54);
        priorityQueue.add(51);
        priorityQueue.add(1);
        priorityQueue.add(100);
        System.out.println(priorityQueue.remove());//控制台输出1
    }
}

```

## 二叉树

### 144. 二叉树的前序遍历

给你二叉树的根节点 root ，返回它节点值的 前序 遍历。

递归版本：

```java
public class PreorderTraversal {

    List<Integer> res = new ArrayList<>();

    public List<Integer> preorderTraversal(TreeNode root){
        recursive(root);
        return res;
    }

    //确定递归函数参数及返回类型
    private void recursive(TreeNode root){
        //终止条件
        if(root==null){
            return;
        }
        //单层递归逻辑
        //根节点
        res.add(root.val);
        //左节点
        recursive(root.left);
        //右节点
        recursive(root.right);
    }

}


class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){
        this.val = val;
    }
    TreeNode(int val,TreeNode left,TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

```

迭代版本：

```java
    /**
     * 使用栈来实现二叉树的前序迭代遍历
     * @param root
     * @return
     */
    public List<Integer> preorderTraversalByIterationMethod(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null){
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()){
            TreeNode node = stack.pop();
            result.add(node.val);
            //先将右节点压入栈中
            if (node.right != null){
                stack.push(node.right);
            }
            //将左节点压入栈中
            if (node.left != null){
                stack.push(node.left);
            }
        }
        return result;
    }
```

### 145. 二叉树的后序遍历

给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。

```java
public class PostorderTraversal {

    public List<Integer> postorderTraversal(TreeNode root){
        List<Integer> res = new ArrayList<>();
        recursive(root,res);
        return res;
    }

    //确定递归函数参数及返回类型
    private void recursive(TreeNode root,List<Integer> res){
        //终止条件
        if(root==null){
            return;
        }
        //单层递归逻辑
        //左子树
        recursive(root.left,res);
        //右子树
        recursive(root.right,res);
        //根节点
        res.add(root.val);
    }
}

class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){
        this.val = val;
    }
    TreeNode(int val,TreeNode left,TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

迭代版本：

```java
/**
     * 二叉树的后序迭代遍历（在前序遍历迭代版本的基础上修改：根左右（前序）→根右左→反转result数组→得到左右根的结果）
     * @param root
     * @return
     */
    public List<Integer> postorderTraversalByIterationMethod(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if(root==null){
            return result;
        }
        LinkedList<TreeNode> stack = new LinkedList<>();
        stack.push(root);
        while (!stack.isEmpty()){
            TreeNode node = stack.pop();
            result.add(node.val);
            if (node.left != null){
                stack.push(node.left);
            }
            if (node.right != null){
                stack.push(node.right);
            }
        }
        Collections.reverse(result);
        return result;
    }
```

### 94. 二叉树的中序遍历

给定一个二叉树的根节点 root ，返回它的中序遍历 。

```java
public class InorderTraversal {
    public List<Integer> inorderTraversal(TreeNode root){
        List<Integer> res = new ArrayList<>();
        recursive(root,res);
        return res;
    }

    //确定递归函数参数及返回类型
    private void recursive(TreeNode root,List<Integer> res){
        //终止条件
        if(root==null){
            return;
        }
        //中序遍历单层递归逻辑
        //左子树
        recursive(root.left,res);
        //根节点
        res.add(root.val);
        //右子树
        recursive(root.right,res);
    }
}
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){
        this.val = val;
    }
    TreeNode(int val,TreeNode left,TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

迭代版本：

```java
   /**
     * 二叉树的中序迭代遍历
     * @param root
     * @return
     */
    public List<Integer> inorderTraversalByIterationMethod(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root==null){
            return res;
        }
        LinkedList<TreeNode> stack = new LinkedList<>();
        TreeNode curNode = root;
        while (curNode!=null||!stack.isEmpty()){
            if(curNode!=null){
                stack.push(curNode);
                curNode = curNode.left;
            }else {
                curNode = stack.pop();
                res.add(curNode.val);
                curNode = curNode.right;
            }
        }
        return res;
    }
```

### 102. 二叉树的层序遍历

给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。

队列版本：

```java
public class LevelOrder {
    /**
     * 二叉树的层序遍历(使用队列实现)
     * @param root
     * @return
     */
    public List<List<Integer>> levelOrder(TreeNode root){
        List<List<Integer>> res = new ArrayList<>();
        if(root==null){
            return res;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        //每一层while循环收集二叉树一层的值
        while (!queue.isEmpty()){
            List<Integer> levelRes = new ArrayList<>();
            int size = queue.size();
             //下面for循环中的条件不能写成i<queue.size(),不然每一层的结果集中会混有其它层的结果
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.remove();
                levelRes.add(node.val);
                if(node.left!=null){
                    queue.offer(node.left);
                }
                if(node.right!=null){
                    queue.offer(node.right);
                }
            }
            res.add(levelRes);
        }
        return res;
    }
}
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){
        this.val = val;
    }
    TreeNode(int val,TreeNode left,TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

递归版本：

```java
public class LevelOrderByRecursion {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> levelOrderByRecursion(TreeNode root){
        recursion(root,0);
        return res;
    }
    //确定递归参数及返回值
    private void recursion(TreeNode root,Integer deep){
        //终止条件
        if(root==null){
            return;
        }
        deep++;
        //单层递归逻辑
        if(res.size()<deep){
            //每一层创建一个ArrayList
            res.add(new ArrayList<>());
        }
        //res的索引0,1,2对应deep中的1,2,3
        res.get(deep-1).add(root.val);
        recursion(root.left,deep);
        recursion(root.right,deep);
    }
}

class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){
        this.val = val;
    }
    TreeNode(int val,TreeNode left,TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

### 107. 二叉树的层序遍历Ⅱ

给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

```java
public class LevelOrderBottom {

    List<List<Integer>> res = new ArrayList<>();

    public List<List<Integer>> levelOrderBottom(TreeNode root){
        recursion(root,0);
        List<List<Integer>> result = new ArrayList<>();
        for (int i = res.size() - 1; i >= 0; i--) {
            result.add(res.get(i));
        }
        return result;
    }

    //确定递归函数及返回值
    private void recursion(TreeNode root,int deep){
        //递归终止条件
        if(root==null){
            return;
        }
        deep++;
        //单层递归逻辑
        if(res.size()<deep){
            res.add(new ArrayList<>());
        }
        res.get(deep-1).add(root.val);
        //递归
        recursion(root.left,deep);
        recursion(root.right,deep);
    }
}
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){
        this.val = val;
    }
    TreeNode(int val,TreeNode left,TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

### 199. 二叉树的右视图

给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

递归版本1(层序遍历)：

```java
public class RightSideView {

    public List<Integer> rightSideView(TreeNode root){
        List<List<Integer>> res = new ArrayList<>();
        recursion(root,0,res);
        List<Integer> list = new ArrayList<>();
        for (List<Integer> e : res) {
            list.add(e.get(e.size()-1));
        }
        return list;
    }

    //确定递归函数及返回值
    private void recursion(TreeNode root,int deep,List<List<Integer>> res){
        //递归终止条件
        if(root==null){
            return;
        }
        deep++;
        //单层递归逻辑
        if(res.size()<deep){
            res.add(new ArrayList<>());
        }
        res.get(deep-1).add(root.val);
        //递归
        recursion(root.left,deep,res);
        recursion(root.right,deep,res);
    }

}
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){
        this.val = val;
    }
    TreeNode(int val,TreeNode left,TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

递归版本2(dfs)：

```java
class Solution {
  public List<Integer> rightSideView(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        recursion(root,0,res);
        return res;
    }

    //确定递归函数参数及返回值
    private void recursion(TreeNode root, int depth, List<Integer> res) {
        //终止条件
        if(root==null){
            return;
        }
        //单层递归逻辑：节点访问顺序为根→右→左
        //如果当前节点的深度==res.size()，则本层中当前节点是第一个被访问的节点
        if(depth==res.size()){
            res.add(root.val);
        }
        depth++;
        recursion(root.right,depth,res);
        recursion(root.left,depth,res);
    }
}
```

### 637. 二叉树的层平均值

给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10^-5 以内的答案可以被接受。

```java
    public List<Double> averageOfLevels(TreeNode root){
        List<List<Integer>> list = new ArrayList<>();
        recursion(root,0,list);
        List<Double> res = new ArrayList<>();
        for (List<Integer> k : list) {
            res.add(k.stream().mapToDouble(Integer::doubleValue).average().orElse(0));
            //double sum = 0;
            //for (Integer e : k) {
            //    sum+=e;
            //}
            //res.add(sum/k.size());
        }
        return res;
    }

    //确定递归函数参数和返回值
    private void recursion(TreeNode root,int depth,List<List<Integer>> list){
        //终止条件
        if(root==null){
            return;
        }
        //单层递归逻辑
        if(depth>= list.size()){
            list.add(new ArrayList<>());
        }
        depth++;
        list.get(depth-1).add(root.val);
        recursion(root.left,depth,list);
        recursion(root.right,depth,list);
    }
```

### 429. N叉树的层序遍历

给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。


![N叉树的层序遍历-2022-06-06-16-42-56](https://images-1309978559.cos.ap-chengdu.myqcloud.com/blogimages/N叉树的层序遍历-2022-06-06-16-42-56.png)

```java
public class NLevelOrder {

    public List<List<Integer>> nLevelOrder(Node root){
        List<List<Integer>> res = new ArrayList<>();
        recursion(root,0,res);
        return res;
    }

    //确定递归参数及返回值
    private void recursion(Node root,Integer deep,List<List<Integer>> res){
        //终止条件
        if(root==null){
            return;
        }
        deep++;
        //单层递归逻辑
        if(res.size()<deep){
            //每一层创建一个ArrayList
            res.add(new ArrayList<>());
        }
        //res的索引0,1,2对应deep中的1,2,3
        res.get(deep-1).add(root.val);
        int size = root.children.size();
        for (int i = 0; i < size; i++) {
            recursion(root.children.get(i),deep,res);
        }
    }

}

class Node{
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
}

```

### 515. 在每个树行中找最大值

给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。

```java
  public List<Integer> largestValues(TreeNode root){
        List<Integer> res = new ArrayList<>();
        recursion(root,0,res);
        return res;
    }

    //确定递归参数及返回值
    private void recursion(TreeNode root,Integer deep,List<Integer> res){
        //终止条件
        if(root==null){
            return;
        }
        deep++;
        //单层递归逻辑
        //将每一层第一个访问的元素加入数组中
        if(res.size()<deep){
            res.add(root.val);
        }
        if(root.val>res.get(deep-1)){
            //移除deep-1位置上的元素，deep-1位置以后的所有元素往左移动一个位置（即元素索引减一）
            res.remove(deep-1);
            //在deep-1位置上插入一个元素root.val，原来deep-1位置及以后的所有元素往右移动一个位置（即元素索引加一）
            res.add(deep-1,root.val);
        }
        recursion(root.left,deep,res);
        recursion(root.right,deep,res);
    }

    //测试
    public static void main(String[] args) {
        List<Integer> res = new ArrayList<>();
        res.add(1);
        res.add(2);
        res.add(3);
        System.out.println(res.indexOf(1));
        System.out.println(res.indexOf(2));
        System.out.println(res.indexOf(3));
        System.out.println("================");
        res.add(1,5);
        System.out.println(res.indexOf(1));
        System.out.println(res.indexOf(2));
        System.out.println(res.indexOf(3));
        System.out.println(res.indexOf(5));
    }

```

### 116. 填充每个节点的下一个右侧节点指针

给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```c++
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。初始状态下，所有 next 指针都被设置为 NULL。

```java
public class Connect {

    public Node connect(Node root){
        if(root==null){
            return root;
        }
        Queue<Node> queue = new LinkedList<>();
        queue.add(root);
        while (!queue.isEmpty()){
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                Node node = queue.remove();
                node.next=i==size-1?null:queue.peek();
                if(node.left!=null){
                    queue.offer(node.left);
                }
                if(node.right!=null){
                    queue.offer(node.right);
                }
            }
        }
        return root;
    }

}

class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
}
```

### 117. 填充每个节点的下一个右侧节点指针 II

给定一个二叉树

```c++
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。初始状态下，所有 next 指针都被设置为 NULL。

进阶：
你只能使用常量级额外空间。
使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。

```java
public class Connect {

    public Node connect(Node root){
        if(root==null){
            return root;
        }
        Queue<Node> queue = new LinkedList<>();
        queue.add(root);
        while (!queue.isEmpty()){
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                Node node = queue.remove();
                //queue.peek():如果队列不为空，返回但不从队列中移除队列的头节点；如果队列为空，返回null
                node.next=i==size-1?null:queue.peek();
                if(node.left!=null){
                    queue.offer(node.left);
                }
                if(node.right!=null){
                    queue.offer(node.right);
                }
            }
        }
        return root;
    }

}


class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
}
```

### 104. 二叉树的最大深度

给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。说明: 叶子节点是指没有子节点的节点。
示例：
给定二叉树 [3,9,20,null,null,15,7]，返回它的最大深度 3 。

递归版本1：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
   public int maxDepth(TreeNode root){
        return recursion(root);
    }
    
    //确定递归函数参数及返回值
    private int recursion(TreeNode root){
        //终止条件
        if(root==null){
            return 0;
        }
        //单层递归逻辑
        int left = recursion(root.left);
        int rigth = recursion(root.right);
        return Math.max(left,rigth)+1;
    }
    
}
```

优雅的递归版本2：

```java
    public int maxDepth(TreeNode root){
        return root==null?0:Math.max(maxDepth(root.left),maxDepth(root.right))+1;
    }
```

### 111. 二叉树的最小深度

给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。说明：叶子节点是指没有子节点的节点。

广度优先（使用队列实现）：

```java
public class MinDepth {
    public int minDepth(TreeNode root){
        int res = 0;
        if(root==null){
            return res;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()){
            res++;
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.remove();
                if(node.left==null&&node.right==null){
                    return res;
                }
                if(node.left!=null){
                    queue.offer(node.left);
                }
                if(node.right!=null){
                    queue.offer(node.right);
                }
            }
        }
        return res;
    }
}
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){
        this.val = val;
    }
    TreeNode(int val,TreeNode left,TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

递归版本1：

```java
public class MinDepth {
    public int minDepth(TreeNode root){
        return recursion(root);
    }
    //确定递归函数参数及返回值
    private int recursion(TreeNode root){
        //终止条件
        if(root==null){
            return 0;
        }
        //单层递归逻辑
        //左右子树都为null
        if(root.left==null&&root.right==null){
            return 1;
        }
        //左右子树有一个null
        int left = recursion(root.left);
        int rigth = recursion(root.right);
        if(root.left==null||root.right==null){
            return Math.max(left,rigth)+1;
        }
        //左右子树都不为null
        return Math.min(left,rigth)+1;
    }
}
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){
        this.val = val;
    }
    TreeNode(int val,TreeNode left,TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

```

递归版本1代码优化：

```java
public class MinDepth {
    public int minDepth(TreeNode root){
        if(root==null) return 0;
        if(root.left==null&&root.right==null) return 1;
        int left = minDepth(root.left);
        int rigth = minDepth(root.right);
        return (root.left==null||root.right==null)?Math.max(left,rigth)+1:Math.min(left,rigth)+1;
    }
}
```

### 226. 翻转二叉树

给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。

层序遍历版本：

```java
public class InvertTree {
    /**
     * 关键：将每一个节点的左右孩子进行交换即可
     * @param root
     * @return
     */
    public TreeNode invertTree(TreeNode root){
        if(root==null){
            return root;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()){
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.remove();
                swap(node);
                if(node.left!=null){
                    queue.offer(node.left);
                }
                if(node.right!=null){
                    queue.offer(node.right);
                }
            }
        }
        return root;
    }

    private void swap(TreeNode node){
        TreeNode temp = node.left;
        node.left = node.right;
        node.right = temp;
    }

}
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){
        this.val = val;
    }
    TreeNode(int val,TreeNode left,TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

递归版本(使用前序遍历)：

```java
public class InvertTreeByRecursion {
    public TreeNode invertTree(TreeNode root){
        //递归终止条件
        if(root==null) return root;
        //单层递归逻辑
        swap(root);
        invertTree(root.left);
        invertTree(root.right);
        return root;
    }
    private void swap(TreeNode node){
        TreeNode temp = node.left;
        node.left = node.right;
        node.right = temp;
    }
}
```

### 101. 对称二叉树

给你一个二叉树的根节点 root ， 检查它是否轴对称。

```java
public class IsSymmetric {
    /**
     * 理解如何通过递归同时遍历左子树和右子树
     * @param root
     * @return
     */
    public boolean isSymmetric(TreeNode root){
        return recursion(root.left, root.right);
    }

    private boolean recursion(TreeNode left, TreeNode right) {
        //left和right节点都为null
        if(left==null&&right==null){
            return true;
        }
        //left节点为null，right节点不为null或者left节点不为null，right节点为null
        if(left==null||right==null){
            return false;
        }
        //left和right节点都不为null
        if(left.val!=right.val){
            return false;
        }
        //内侧
        boolean inside = recursion(left.right,right.left);
        //外侧
        boolean outside = recursion(left.left,right.right);
        //想不到inside&&outside这种写法
        return inside&&outside;
    }
}
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){
        this.val = val;
    }
    TreeNode(int val,TreeNode left,TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

### 222. 完全二叉树的节点个数

给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。

递归版本1：

```java
public class CountNodes {
    /**
     * 二叉树的前序遍历
     * @param root
     * @return
     */
    public int countNodes(TreeNode root){
        return recursion(root);
    }

    //确定递归函数参数及返回值
    private int recursion(TreeNode root){
        //递归终止条件
        if(root==null){
            return 0;
        }
        //单层递归逻辑
        int left = recursion(root.left);
        int right = recursion(root.right);
        return left+right+1;
    }

}
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){
        this.val = val;
    }
    TreeNode(int val,TreeNode left,TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

递归版本1优化：

```java
public class CountNodes {
    public int countNodes(TreeNode root){
        return root==null?0:countNodes(root.left)+countNodes(root.right)+1;
    }
}
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){
        this.val = val;
    }
    TreeNode(int val,TreeNode left,TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

### 110. 平衡二叉树

给定一个二叉树，判断它是否是高度平衡的二叉树。本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点的左右两个子树的高度差的绝对值不超过 1 。

```java
public class IsBalanced {
    /**
     * 求二叉树的高度（自底向上）一般采用后序遍历，求二叉树的深度（自顶向下）一般采用前序遍历
     * @param root
     * @return
     */
    public boolean isBalanced(TreeNode root){
        return recursion(root)!=-1;
    }

    /**
     * 确定递归函数参数及返回值
     * @param root
     * @return
     */
    private int recursion(TreeNode root){
        //终止条件
        if(root==null){
            return 0;
        }
        //单层递归逻辑
        int leftHeight = recursion(root.left);
        if(leftHeight==-1){
            return -1;
        }
        int rightHeight = recursion(root.right);
        if(rightHeight==-1){
            return -1;
        }
        if(Math.abs(leftHeight-rightHeight)>1){
            return -1;
        }
        return Math.max(leftHeight,rightHeight)+1;
    }
}
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){
        this.val = val;
    }
    TreeNode(int val,TreeNode left,TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

### 257. 二叉树的所有路径

给你一个二叉树的根节点 root ，按任意顺序 ，返回所有从根节点到叶子节点的路径。叶子节点是指没有子节点的节点。

```java
public class BinaryTreePaths {
    public List<String> binaryTreePaths(TreeNode root){
        List<String> res = new ArrayList<>();
        String s = "";
        recursion(root,res,s);
        return res;
    }

    /**
     * 深入理解每层递归中变量s值的变化(理解java中的值传递)，每层递归隐藏了回溯
     * @param root
     * @param res
     * @param s
     */
    private void recursion(TreeNode root,List<String> res,String s){
        //递归终止条件
        if(root==null){
            return;
        }
        s += root.val;
        if(root.left==null&&root.right==null){
            res.add(new String(s));
            return;
        }
        recursion(root.left,res,s+"->");
        recursion(root.right,res,s+"->");
    }
}
```

### 404. 左叶子之和

给定二叉树的根节点 root ，返回所有左叶子之和。

中序遍历版本：

```java
public class SumOfLeftLeaves {
    int sum = 0;
    public int sumOfLeftLeaves(TreeNode root){
        if(root==null) return 0;
        recursion(root);
        return sum;
    }

    //确定递归函数参数及返回值
    private void recursion(TreeNode root){
        //递归终止条件
        if(root==null) return;
        //单层递归逻辑：
        //左子树
        recursion(root.left);
        //如果root.left是左叶子，那么把root.left.val的值累加到sum上
        sum+=(root.left!=null&&root.left.left==null&&root.left.right==null)?root.left.val:0;
        //右子树
        recursion(root.right);
    }
}
```

### 513. 找树左下角的值

给定一个二叉树的根节点 root，请找出该二叉树的最底层最左边节点的值。假设二叉树中至少有一个节点。

前序遍历版本：

```java
public class FindBottomLeftValue {
    private int maxDepth = 0;
    private int res = 0;
    public int findLeftBottomValue(TreeNode root){
        if(root==null) return 0;
        res = root.val;
        recursion(root,0);
        return res;
    }
    
    //确定递归函数参数及返回值
    private void recursion(TreeNode root,int curDepth){
        //终止条件
        if(root==null){
            return;
        }
        if(root.left==null&&root.right==null){
            if(curDepth>maxDepth){
                maxDepth = curDepth;
                res = root.val;
            }
            return;
        }
        //单层递归逻辑
        recursion(root.left,curDepth+1);//递归隐藏着回溯
        recursion(root.right, curDepth+1);
    }
}
```

层序遍历版本：

```java
public class FindBottomLeftValue {
    public int findLeftBottomValue(TreeNode root){
        if(root==null) return 0;
        TreeNode finalRoot = root;
        Queue<TreeNode> queue = new LinkedList<>(){{
            offer(finalRoot);
        }};
        while (!queue.isEmpty()){
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                root = queue.remove();
                if(root.right!=null) queue.offer(root.right);
                if(root.left!=null) queue.offer(root.left);
            }
        }
        return root.val;
    }

}
```

### 112. 路径总和

给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。叶子节点 是指没有子节点的节点。

递归版本1：

```java
public class HasPathSum {

    public boolean hasPathSum(TreeNode root,int targetSum){
        return root==null?false:recursion(root,targetSum,root.val);
    }

    //确定递归函数参数及返回值
    private boolean recursion(TreeNode root,int targetSum,int sum){
        //终止条件
        if(root==null) return false;
        if(root.left==null&&root.right==null){
            return sum==targetSum?true:false;
        }
        //单层递归逻辑
        boolean left = recursion(root.left,targetSum,sum+(root.left==null?0:root.left.val));
        boolean right = recursion(root.right,targetSum,sum+(root.right==null?0:root.right.val));
        return (left||right);
    }
}
```

递归版本2：

```java
    //确定递归函数参数及返回值
    public boolean hasPathSum(TreeNode root,int targetSum){
        //终止条件
        if(root==null) return false;
        if(root.left==null&&root.right==null){
            return root.val==targetSum;
        }
        //单层递归逻辑
        boolean left = hasPathSum(root.left,targetSum-root.val);
        boolean right = hasPathSum(root.right,targetSum-root.val);
        return (left||right);
    }
```

递归版本2优化：

```java
    //确定递归函数参数及返回值
    public boolean hasPathSum(TreeNode root,int targetSum){
        //终止条件
        if(root==null) return false;
        if(root.left==null&&root.right==null) return root.val==targetSum;
        //单层递归逻辑
        return (hasPathSum(root.left,targetSum-root.val)||hasPathSum(root.right,targetSum-root.val));
    }
```

### 113. 路径总和Ⅱ

给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。叶子节点 是指没有子节点的节点。

```java
public class PathSum {
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        List<List<Integer>> res = new ArrayList<>();
        LinkedList<Integer> path = new LinkedList<>();
        recursion(root,targetSum,res,path);
        return res;
    }

    //确定递归函数参数及返回值
    private void recursion(TreeNode root,int targetSum,List<List<Integer>> res,LinkedList<Integer> path){
        //终止条件
        if(root==null) return;
        //单层递归逻辑
        path.add(root.val);
        if(root.left==null&&root.right==null){
            if(targetSum==root.val){
                res.add(new ArrayList<>(path));
            }
            return;
        }
        //递归
        recursion(root.left,targetSum- root.val,res,path);
        if(root.left!=null){
            //回溯
            path.removeLast();
        }
        recursion(root.right,targetSum- root.val,res,path);
        if(root.right!=null){
            path.removeLast();
        }
    }
}
```

### 106. 从中序与后序遍历序列构造二叉树

给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。

```java
public class BuildTree {

    public TreeNode buildTree(int[] inorder,int[] postorder){
        return recursion(inorder,0, inorder.length, postorder,0, postorder.length);
    }


    //确定递归函数参数及返回值
    private TreeNode recursion(int[] inorder,int inLeft,int inRight,int[] postorder,int postLeft,int postRight){
        /*递归终止条件*/
        if(inRight-inLeft<1) return null;
        //只有一个元素
        if(inRight-inLeft==1) return new TreeNode(inorder[inLeft]);
        //后序遍历数组的最后一个元素是根节点
        int rootVal = postorder[postRight - 1];
        TreeNode root = new TreeNode(rootVal);
        int rootIndex = 0;
        //在中序遍历数组中找到根节点的下标
        for (int i = inLeft;i<inRight;i++){
            if(inorder[i]==rootVal){
                rootIndex = i;
                break;
            }
        }
        //递归recursion(中序遍历左数组，后序遍历左数组)
        root.left = recursion(inorder, inLeft, rootIndex, postorder, postLeft, postLeft + rootIndex - inLeft);
        //递归recursion(中序遍历右数组，后序遍历右数组)
        root.right = recursion(inorder, rootIndex+1, inRight, postorder,postLeft + rootIndex - inLeft, postRight-1);
        return root;
    }
}
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){
        this.val = val;
    }
    TreeNode(int val,TreeNode left,TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

### 105. 从前序与中序遍历构造二叉树

给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。

```java
public class BuildTreeByPreorderAndInorder {
    public TreeNode buildTree(int[] preorder,int[] inorder){
        return recursion(preorder,0, preorder.length-1, inorder,0, inorder.length-1);
    }

    //确定递归函数参数及返回值
    private TreeNode recursion(int[] preorder,int preLeft,int preRight,int[] inorder,int inLeft,int inRight){
        //递归终止条件
        //还有一个元素
        if(preRight-preLeft==0){
            return new TreeNode(preorder[preRight]);
        }
        //没有元素
        if(preRight-preLeft<0){
            return null;
        }
        //单层递归逻辑
        TreeNode root = new TreeNode(preorder[preLeft]);
        int rootIndex = 0;
        for (int i = 0; i < inorder.length; i++) {
            if(inorder[i]==root.val){
                rootIndex = i;
                break;
            }
        }
        //recursion(前序遍历左数组，中序遍历左数组)，不变量采用左闭右闭原则([])
        //前序遍历左数组右边界的推导：preRight-(preLeft+1)+1=rootIndex-inLeft(备注：区间长度相等)
        root.left = recursion(preorder,preLeft+1,rootIndex-inLeft+preLeft,inorder,inLeft,rootIndex-1);
        //recursion(前序遍历右数组，中序遍历右数组)
        root.right = recursion(preorder,rootIndex-inLeft+preLeft+1,preRight,inorder,rootIndex+1,inRight);
        return root;
    }
}
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){
        this.val = val;
    }
    TreeNode(int val,TreeNode left,TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

### 654. 最大二叉树

给定一个不重复的整数数组 nums 。最大二叉树可以用下面的算法从nums递归地构建:(1)创建一个根节点，其值为 nums 中的最大值。(2)递归地在最大值左边的子数组前缀上构建左子树。(3)递归地在最大值右边的子数组后缀上构建右子树。返回 nums 构建的最大二叉树 。

递归版本一：

```java
public class ConstructMaximumBinaryTree {
    public TreeNode constructMaximumBinaryTree(int[] nums){
        return recursion(nums,0,nums.length-1);
    }

    /**
     * 确定递归函数参数及返回值
     * @param nums
     * @param left
     * @param right
     * @return
     */
    private TreeNode recursion(int[] nums,int left,int right){
        //终止条件
        if(right-left==0){
            return new TreeNode(nums[left]);
        }
        if(right-left<0){
            return null;
        }
        //单层递归逻辑
        int value = maxValue(nums, left, right);
        TreeNode root = new TreeNode(value);
        //最大值在数组中的下标记为maxIndex
        int maxIndex = 0;
        for (int i = left; i <=right; i++) {
            if(nums[i]==value){
                maxIndex = i;
            }
        }
        root.left = recursion(nums,left,maxIndex-1);
        root.right = recursion(nums,maxIndex+1,right);
        return root;
    }

    /**
     * 求数组中的最大值
     * @param nums
     * @param left
     * @param right
     * @return
     */
    private int maxValue(int[] nums,int left,int right){
        int res = 0;
        for (int i = left; i <=right; i++) {
            if(nums[i]>res){
                res = nums[i];
            }
        }
        return res;
    }
}
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){
        this.val = val;
    }
    TreeNode(int val,TreeNode left,TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

递归版本一优化：

```java
    public TreeNode constructMaximumBinaryTree(int[] nums){
        return recursion(nums,0,nums.length-1);
    }

    /**
     * 确定递归函数参数及返回值
     * @param nums
     * @param left
     * @param right
     * @return
     */
    private TreeNode recursion(int[] nums,int left,int right){
        //终止条件
        if(right-left==0) return new TreeNode(nums[left]);
        if(right-left<0) return null;
        //单层递归逻辑
        //最大值在数组中的下标记为maxIndex
        int maxIndex = 0;
        //数组中的最大值记为maxValue
        int maxValue = 0;
        //遍历数组
        for (int i = left; i <=right; i++) {
            if(nums[i]>maxValue){
                maxIndex = i;
                maxValue = nums[i];
            }
        }
        TreeNode root = new TreeNode(maxValue);
        root.left = recursion(nums,left,maxIndex-1);
        root.right = recursion(nums,maxIndex+1,right);
        return root;
    }
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){
        this.val = val;
    }
    TreeNode(int val,TreeNode left,TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

### 617. 合并二叉树

给你两棵二叉树： root1 和 root2 。想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。返回合并后的二叉树。注意: 合并过程必须从两个树的根节点开始。

递归版本1：

```java
public class MergeTrees {
    public TreeNode mergeTrees(TreeNode root1,TreeNode root2){
        return recursion(root1, root2);
    }

    private TreeNode recursion(TreeNode root1,TreeNode root2){
        //终止条件
        if(root1==null&&root2==null){
            return null;
        }
        if(root1==null&&root2!=null){
            return root2;
        }
        if(root1!=null&&root2==null){
            return root1;
        }
        //单层递归逻辑
        int rootValue = root1.val+root2.val;
        TreeNode root = new TreeNode(rootValue);
        root.left = recursion(root1.left,root2.left);
        root.right = recursion(root1.right,root2.right);
        return root;
    }
}
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){
        this.val = val;
    }
    TreeNode(int val,TreeNode left,TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

递归版本1优化：

```java
public TreeNode mergeTrees(TreeNode root1,TreeNode root2){
        if(root1==null) return root2;
        if(root2==null) return root1;
        TreeNode root = new TreeNode(root1.val+ root2.val);
        root.left = mergeTrees(root1.left,root2.left);
        root.right = mergeTrees(root1.right,root2.right);
        return root;
    }
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){
        this.val = val;
    }
    TreeNode(int val,TreeNode left,TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

### 700. 二叉搜索树中的搜索

给定二叉搜索树（BST）的根节点 root 和一个整数值 val。你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。

递归版本1：

```java
public class SearchBST {
    public TreeNode searchBST(TreeNode root,int val){
        //终止条件
        if(root==null){
            return null;
        }
        if(root.val==val){
            return root;
        }
        //单层递归逻辑
        TreeNode left = searchBST(root.left,val);
        TreeNode right = searchBST(root.right,val);
        return left==null?right:left;
    }
}
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){
        this.val = val;
    }
    TreeNode(int val,TreeNode left,TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

递归版本2：

```java
public class SearchBST {
    /**
     * 根据二叉搜索树的特点对递归进行优化，减少递归搜索次数
     * @param root
     * @param val
     * @return
     */
    public TreeNode searchBST(TreeNode root,int val){
        //终止条件
        if(root==null||root.val==val) {
            return root;
        }
        //单层递归逻辑
        if(val< root.val){
            return searchBST(root.left,val);
        }else {
            return searchBST(root.right,val);
        }
    }
}
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){
        this.val = val;
    }
    TreeNode(int val,TreeNode left,TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

### 98. 验证二叉搜索树

给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。有效二叉搜索树定义如下：
（1）节点的左子树只包含 小于 当前节点的数。
（2）节点的右子树只包含 大于 当前节点的数。
（3）所有左子树和右子树自身必须也是二叉搜索树。

版本1：

```java

public class IsValidBST {
    public boolean isValidBST(TreeNode root){
        List<Long> res = new ArrayList<>();
        recursion(root,res);
        //本质就是判断一个数组是否有序，还要注意溢出的问题
        for (int i = 1; i < res.size(); i++) {
            if(res.get(i)- res.get(i-1)<=0){
                return false;
            }
        }
        return true;
    }

    //确定递归函数参数及返回值
    private void recursion(TreeNode root,List<Long> res){
        //递归终止条件
        if(root==null) return;
        //单层递归逻辑
        recursion(root.left,res);
        res.add((long) root.val);
        recursion(root.right,res);
    }
}
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){
        this.val = val;
    }
    TreeNode(int val,TreeNode left,TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

递归版本2：

```java
public class IsValidBST {
    long pre = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        if (root == null) {
            return true;
        }
        // 访问左子树
        boolean left = isValidBST(root.left);
        if (!left) {
            return false;
        }
        // 访问当前节点：如果当前节点小于等于中序遍历的前一个节点，说明不满足BST，返回 false；否则继续遍历。
        if (root.val <= pre) {
            return false;
        }
        pre = root.val;
        // 访问右子树
        boolean right =isValidBST(root.right);
        return left&&right;
    }
}
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){
        this.val = val;
    }
    TreeNode(int val,TreeNode left,TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

Notes: 

- 二叉搜索树的中序遍历是递增序列
- 空树也是二叉搜索树

### 530. 二叉搜索树的最小绝对差

给你一个二叉搜索树的根节点 root ，返回树中任意两不同节点值之间的最小差值 。差值是一个正数，其数值等于两值之差的绝对值。

```java
//理解如何保存当前节点的前一个节点
public class GetMinimumDifference {
    int res = 100001;
    TreeNode pre;
    public int getMinimumDifference(TreeNode root){
        recursion(root);
        return res;
    }
    //确定递归函数参数及返回值
    private void recursion(TreeNode root){
        if(root==null){
            return;
        }
        recursion(root.left);
        if(pre!=null){
            res = Math.min(res,root.val- pre.val);
        }
        pre = root;
        recursion(root.right);
    }
}
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){
        this.val = val;
    }
    TreeNode(int val,TreeNode left,TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

### 501. 二叉搜索树中的众数

给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。如果树中有不止一个众数，可以按 任意顺序 返回。假定 BST 满足如下定义：

- 结点左子树中所含节点的值 小于等于 当前节点的值
- 结点右子树中所含节点的值 大于等于 当前节点的值
- 左子树和右子树都是二叉搜索树

暴力版本（普通二叉树通用方法）：

```java
//mode有众数的意思
public class FindMode {
    public int[] findMode(TreeNode root) {
        Map<Integer, Integer> map = new HashMap<>();
        recursion(root,map);
        ArrayList<Integer> list = new ArrayList<>();
        int count = 0;
        for (Integer value : map.values()) {
            if(value>count){
                count = value;
            }
        }
        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
            if(entry.getValue()==count){
                list.add(entry.getKey());
            }
        }
        int[] res = new int[list.size()];
        for (int i = 0; i < list.size(); i++) {
            res[i] = list.get(i);
        }
        return res;
    }
    
    //确定递归函数参数及返回值
    private void recursion(TreeNode root, Map<Integer, Integer> map) {
        //递归终止条件
        if(root==null){
            return;
        }
        //单层递归逻辑
        map.put(root.val, map.getOrDefault(root.val,0)+1);
        recursion(root.left,map);
        recursion(root.right,map);
    }
}
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){
        this.val = val;
    }
    TreeNode(int val,TreeNode left,TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

优化空间版本（针对二叉搜索树才有用）

```java
public class FindMode {
    ArrayList<Integer> resList;
    int maxFrequency;
    int frequency;
    //pre指针指向当前节点的前一个节点
    TreeNode pre;
    public int[] findMode(TreeNode root){
        resList = new ArrayList<>();
        maxFrequency = 0;
        frequency = 0;
        pre = null;
        recursion(root);
        int[] res = new int[resList.size()];
        for (int i = 0; i < resList.size(); i++) {
            res[i] = resList.get(i);
        }
        return res;
    }
    //确定递归函数参数与返回值
    private void recursion(TreeNode root){
        //终止条件
        if(root==null) return;

        //单层递归逻辑
        recursion(root.left);
        int rootValue = root.val;
        if(pre==null||pre.val!=rootValue){
            frequency = 1;
        }else{
            frequency++;
        }
        //如果当前节点出现的频次大于最大频次
        if(frequency>maxFrequency){
            maxFrequency = frequency;
            resList.clear();
            resList.add(rootValue);
        }else if (frequency==maxFrequency){
            resList.add(rootValue);
        }
        //更新pre指针
        pre = root;
        recursion(root.right);
    }
}
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){
        this.val = val;
    }
    TreeNode(int val,TreeNode left,TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

### 236. 二叉树的最近公共祖先

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

```java
public class LowestCommonAncestor {
    /**
     * 后序遍历是天然的回溯
     * @param root
     * @param p
     * @param q
     * @return
     */
    public TreeNode lowestCommonAncestor(TreeNode root, int p, int q) {
        //递归终止条件
        if(root==null|| root.val==p||root.val==q){
            return root;
        }
        //单层递归逻辑
        TreeNode left = lowestCommonAncestor(root.left,p,q);
        TreeNode right = lowestCommonAncestor(root.right,p,q);
        if(left==null&&right==null){
            return null;
        }else if (left==null&&right!=null){
            return right;
        }else if (left!=null&&right==null){
            return left;
        }else{
            return root;
        }
    }
}
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){
        this.val = val;
    }
    TreeNode(int val,TreeNode left,TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

### 235. 二叉搜索树的最近公共祖先

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

递归版本V1：

```java
public class BSTLowestCommonAncestor {
    TreeNode left;
    TreeNode right;

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root.val>p.val&&root.val>q.val){
            left = lowestCommonAncestor(root.left,p,q);
            return left;
        }
        if(root.val<p.val&&root.val<q.val){
            right = lowestCommonAncestor(root.right,p,q);
            return right;
        }
        return root;
    }
}
```

递归优化版V2:

```java
public class BSTLowestCommonAncestor {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        //如果当前节点root的值比p和q节点的值都大，那么遍历左子树
        if(root.val>p.val&&root.val>q.val) return lowestCommonAncestor(root.left,p,q);
        //如果当前节点root的值比p和q节点的值都小，那么遍历右子树
        if(root.val<p.val&&root.val<q.val) return lowestCommonAncestor(root.right,p,q);
        //如果当前节点root的值在p和q之间，那么root就是p和q节点的最近公共祖先
        return root;
    }
}
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){
        this.val = val;
    }
    TreeNode(int val,TreeNode left,TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

### 701. 二叉搜索树中的插入操作

给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。

```java
public class InsertIntoBST {
    /**
     * 重点理解如何通过递归函数返回值完成新创建节点与父节点关系的赋值操作
     * @param root
     * @param val
     * @return
     */
    public TreeNode insertIntoBST(TreeNode root,int val){
        //递归终止条件
        if(root==null){
            return new TreeNode(val);
        }
        //单层递归逻辑：如果当前节点的值比val小，那么递归右子树，反之则递归左子树
        if(val> root.val){
            root.right = insertIntoBST(root.right,val);
        }else {
            root.left = insertIntoBST(root.left,val);
        }
        return root;
    }
}
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){
        this.val = val;
    }
    TreeNode(int val,TreeNode left,TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

### 450. 删除二叉搜索树中的节点

给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。一般来说，删除节点可分为两个步骤：①首先找到需要删除的节点；②如果找到了，删除它。

```java
public class DeleteNode {
    public TreeNode deleteNode(TreeNode root,int key){
        //递归终止条件
        //①要删除的节点不在二叉树中
        if(root==null){
            return null;
        }
        if(root.val==key){
            //②要删除节点的左右子树都为null
            if(root.left==null&&root.right==null){
                return null;
            }else if (root.left!=null&&root.right==null){//③要删除节点的左子树不为null，而右子树为null
                return root.left;
            }else if(root.left==null&&root.right!=null){//④要删除节点的右子树不为null，而左子树为null
                return root.right;
            }else {//⑤要删除节点的左右子树都不为null，将要删除节点的左子树移动到要删除节点的右子树的最左下角的节点的左子树上
                TreeNode temp = root.right;
                //理解如何给定一个节点node，然后找到这个node节点最左下角的节点
                while (temp.left!=null){
                    temp = temp.left;
                }
                temp.left = root.left;
                return root.right;
            }
        }
        //单层递归逻辑
        //理解递归函数的返回值如何与要删除节点的上一个节点建立关系
        if(key> root.val){
            root.right = deleteNode(root.right,key);
        }else {
            root.left = deleteNode(root.left,key);
        }
        return root;
    }
}
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){
        this.val = val;
    }
    TreeNode(int val,TreeNode left,TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

### 669. 修剪二叉搜索树

给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树不应该改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在唯一的答案 。所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。

```java
public class TrimBST {
    public TreeNode trimBST(TreeNode root,int low,int high){
        //递归终止条件
        //要删除的节点不在二叉树中
        if(root==null){
            return null;
        }
        //单层递归逻辑
        //理解递归函数的返回值如何与要删除节点的上一个节点建立关系
        if(root.val<low){//root结点的值在区间[low,high]左边
            return trimBST(root.right,low,high);
        }else if (root.val>high){ //root结点的值在区间[low,high]右边
            return trimBST(root.left,low,high);
        }
        //root结点的值在区间[low,high]中间
        root.left = trimBST(root.left,low,high);
        root.right = trimBST(root.right,low,high);
        return root;
    }
}
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){
        this.val = val;
    }
    TreeNode(int val,TreeNode left,TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

### 108. 将有序数组转换为二叉搜索树

给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。

```java
public class SortedArrayToBST {
    public TreeNode sortedArrayToBST(int[] nums){
        return recursion(nums,0,nums.length-1);
    }
    //确定递归函数参数及返回值
    private TreeNode recursion(int[] nums,int left,int right){
        //递归终止条件
        if(right==left){
            return new TreeNode(nums[left]);
        }
        if(right-left<0){
            return null;
        }
        //根节点在数组中的下标
        //int rootIndex = (left+right)/2;//注意溢出的风险
        int rootIndex = left+(right-left)/2;
        TreeNode root = new TreeNode(nums[rootIndex]);
        //单层递归逻辑
        root.right = recursion(nums,rootIndex+1,right);
        root.left = recursion(nums,left,rootIndex-1);
        return root;
    }
}
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){
        this.val = val;
    }
    TreeNode(int val,TreeNode left,TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

### 538. 把二叉搜索树转化为累加树

给出二叉搜索树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。提醒一下，二叉搜索树满足下列约束条件：

- 节点的左子树仅包含键 小于 节点键的节点。
- 节点的右子树仅包含键 大于 节点键的节点。
- 左右子树也必须是二叉搜索树。

```java
public class ConvertBST {
    int sum=0;
    public TreeNode convertBST(TreeNode root){
        recursion(root);
        return root;
    }
    private void recursion(TreeNode root){
        //递归终止条件
        if(root==null){
            return;
        }
        //单层递归逻辑
        recursion(root.right);
        sum+= root.val;
        root.val = sum;
        recursion(root.left);
    }
}
class TreeNode{
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(){}
    TreeNode(int val){
        this.val = val;
    }
    TreeNode(int val,TreeNode left,TreeNode right){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

## 回溯算法

### 77. 组合

给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。
你可以按 任何顺序 返回答案。

```java
    List<List<Integer>> result = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();

    /**
     * 回溯搜索的本质是穷举，可以画一个树型结构的辅助遍历图
     * @param n
     * @param k
     * @return
     */
    public List<List<Integer>> combine(int n, int k) {
        combineHelper(n, k, 1);
        return result;
    }

    /**
     * 每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠startIndex
     * @param startIndex 用来记录本层递归中，集合从哪里开始遍历（集合就是[1,...,n] ）。
     */
    private void combineHelper(int n, int k, int startIndex){
        //终止条件
        if (path.size() == k){
            //存放结果
            result.add(new ArrayList<>(path));
            return;
        }
        //for循环横向遍历
        //剪枝优化：for (int i = startIndex; i <= n - (k - path.size()) + 1; i++)
        for (int i = startIndex; i <= n; i++){
            //处理节点
            path.add(i);
            System.out.println("递归之前=>"+path);
            //递归进行纵向遍历
            combineHelper(n, k, i + 1);
            //回溯，撤销处理结果
            path.removeLast();
            System.out.println("递归之后=>"+path);
        }
    }

    public static void main(String[] args) {
        Combine combine = new Combine();
        combine.combine(3,2);
    }
```

### 216. 组合总和Ⅲ

找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：

- 只使用数字1到9
- 每个数字 最多使用一次 
返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。

```java
   List<List<Integer>> res = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();

    public List<List<Integer>> combinationSum3(int k,int n){
        recursive(k,n,1);
        return res;
    }

    //回溯函数模板
    private void recursive(int k,int n,int index){
        //终止条件
        //剪枝优化
        if (path.stream().reduce(Integer::sum).orElse(0)>n){
            return;
        }
        if(path.stream().reduce(Integer::sum).orElse(0)==n&&path.size()==k){
            res.add(new ArrayList<>(path));
            return;
        }
        //剪枝优化：for (int i = index; i <= 3-(k- path.size())+1; i++)
        for (int i = index; i <= 9; i++) {
            //处理节点
            path.add(i);
            // System.out.println("递归之前=>"+path);
            //递归
            recursive(k,n,i+1);
            //回溯返回（递归到底了，该往上层抛）：删除最后一个元素
            path.removeLast();
            // System.out.println("递归之后=>"+path);
        }
    }
```

### 17. 电话号码的字母组合

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![电话号码的字母组合-2022-05-21-16-13-41](https://images-1309978559.cos.ap-chengdu.myqcloud.com/blogimages/电话号码的字母组合-2022-05-21-16-13-41.png)

```java
public class LetterCombinations {

    List<String> res = new ArrayList<>();
    /**
     * StringBuilder线程不安全
     */
    StringBuilder sb = new StringBuilder();

    /**
     * 求不同集合的组合，树形辅助图中的每一层为一个不同的集合
     * @param digits
     * @return
     */
    public List<String> letterCombinations(String digits){
        //判空
        if(digits==null||digits.length()==0){
            return res;
        }

        //确定回溯函数backtracking()参数:String[] s(字符串数组),String digits,index（标记每一层使用那一个数字对应的集合）
        //数字和字符串做映射
        String[] strings = {"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
        backtracking(strings,digits,0);
        return res;
    }


    /**
     * 确定单层遍历逻辑
     * @param s
     * @param digits
     * @param index
     */
    private void backtracking(String[] s,String digits,int index){
        //确定终止条件：index个数等于digits的长度
        if(index==digits.length()){
            res.add(sb.toString());
            return;
        }
        //找到数字对应的字符串
        String str = s[digits.charAt(index)-'0'];
        //for循环
        for (int i = 0; i < str.length(); i++) {
            //处理节点
            sb.append(str.charAt(i));
            //递归
            backtracking(s,digits,index+1);
            //回溯返回
            sb.deleteCharAt(sb.length()-1);
        }
    }
}
```

### 39. 组合总和

给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 对于给定的输入，保证和为 target 的不同组合数少于 150 个。

```java
public class CombinationSum {

    // private static Logger logger = LoggerFactory.getLogger(CombinationSum.class);

    List<List<Integer>> res = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();

    public List<List<Integer>> combinationSum(int[] candidates,int target){
        backtracking(candidates,target,0);
        return res;
    }

    //确定回溯函数及参数
    private void backtracking(int[] candidates,int sum,int starIndex){
        //剪枝
        if(path.stream().reduce(Integer::sum).orElse(0)>sum){
            return;
        }
        //终止条件1
        if(path.stream().reduce(Integer::sum).orElse(0)==sum){
            // res.add(path);会报错
            res.add(new LinkedList<>(path));
            return;
        }
        //单层循环逻辑
        //一个集合求组合的话，需要startIndex，startIndex用于控制for循环的起始位置
        for (int i = starIndex; i < candidates.length; i++) {
            //处理节点
            path.add(candidates[i]);
            // logger.info("递归前=>{}",path);
            //递归
            backtracking(candidates, sum,i);
            //回溯返回
            path.removeLast();
            // logger.info("递归后=>{}",path);
        }
    }
    
}
```

变式：求排列总和，例如输入[2,3,6,7],target为7,结果为[[2,2,3],[2,3,2],[3,2,2],[7]]

```java
public class CombinationSum {

    // private static Logger logger = LoggerFactory.getLogger(CombinationSum.class);

    List<List<Integer>> res = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();

    public List<List<Integer>> combinationSum(int[] candidates,int target){
        backtracking(candidates,target);
        return res;
    }

    //确定回溯函数及参数
    private void backtracking(int[] candidates,int sum){
        //剪枝
        if(path.stream().reduce(Integer::sum).orElse(0)>sum){
            return;
        }
        //终止条件1
        if(path.stream().reduce(Integer::sum).orElse(0)==sum){
            // res.add(path);会报错
            res.add(new LinkedList<>(path));
            return;
        }
        //单层循环逻辑
        for (int i = 0; i < candidates.length; i++) {
            //处理节点
            path.add(candidates[i]);
            // logger.info("递归前=>{}",path);
            //递归
            backtracking(candidates, sum);
            //回溯返回
            path.removeLast();
            // logger.info("递归后=>{}",path);
        }
    }

}
```

### 40. 组合总和Ⅱ

给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的每个数字在每个组合中只能使用 一次 。注意：解集不能包含重复的组合。 

```java
public class CombinationSum2 {

    List<List<Integer>> res = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();

    /**
     * 关键：如何处理[[1,1,6],[1,2,5],[1,7],[1,2,5],[1,7],[2,6]]，数组排序后如何在树层上去重
     * @param candidates
     * @param target
     * @return
     */
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        backtracking(candidates,target,0);
        return res;
    }

    //确定回溯函数及参数
    private void backtracking(int[] candidates, int target,int startIndex){
        //剪枝
        if(path.stream().reduce(Integer::sum).orElse(0)>target){
            return;
        }
        //回溯终止条件
        if(path.stream().reduce(Integer::sum).orElse(0)==target){
            res.add(new LinkedList<>(path));
            return;
        }
        //单层循环逻辑
        for (int i = startIndex; i < candidates.length; i++) {
            //去重
            if(i-1>=0&&candidates[i]==candidates[i-1]&&i>startIndex){
                continue;
            }
            //处理节点
            path.add(candidates[i]);
            //递归
            backtracking(candidates, target, i+1);
            //回溯返回
            path.removeLast();
        }
    }
    
}
```

### 131. 分割回文串

给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。回文串 是正着读和反着读都一样的字符串。

```java
public class Partition {

    List<List<String>> res = new ArrayList<>();
    Deque<String> deque = new LinkedList<>();

    public List<List<String>> partition(String s){
        backtracking(s,0);
        return res;
    }

    /**
     * 确定回溯函数及参数
     * @param s
     * @param startIndex
     */
    private void backtracking(String s,int startIndex){
        //终止条件
        if(startIndex>=s.length()){
            res.add(new ArrayList<>(deque));
            return;
        }
        //单层循环逻辑
        for (int i = startIndex; i < s.length(); i++) {
            if(isPalindrome(s,startIndex,i)){
                String str = s.substring(startIndex, i + 1);
                //deque.addFirst(str)通不过，顺序反掉了
                deque.addLast(str);
            }else {
                continue;
            }
            //递归
            backtracking(s,i+1);
            //回溯返回
            deque.removeLast();
        }
    }

    /**
     * 使用双指针判断字符串是否是回文
     * @param s
     * @param start
     * @param end
     * @return
     */
    private boolean isPalindrome(String s,int start,int end){
        while (start<end){
            if( s.charAt(start)!=s.charAt(end)){
                return false;
            }
            start++;
            end--;
        }
        return true;
    }
    
}
```

### 93. 复原IP地址

有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 IP 地址。给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。


```java
public class RestoreIpAddress {
    List<String> res = new ArrayList<>();

    public List<String> restoreIpAddresses(String s) {
        //剪枝:ip地址最大一位是255，为3位数，即ip地址最长是4×3=12位
        if(s.length()>12){
            return res;
        }
        backtracking(s,0,0);
        return res;
    }

    /**
     * startIndex: 搜索的起始位置， pointNum:添加点(.)分隔符的数量
     * @param s
     * @param startIndex
     * @param pointNum
     */
    private void backtracking(String s, int startIndex, int pointNum) {
        //当点（.）分隔符数量为3时
        if(pointNum==3){
            //判断最后一段子字符串是否合法
            if(isValid(s,startIndex,s.length()-1)){
                res.add(s);
            }
            return;
        }
        for(int i = startIndex;i<s.length();i++){
            if(isValid(s,startIndex,i)){
                //"unhappy".substring(2) returns "happy"
                s = s.substring(0,i+1)+"."+s.substring(i+1);
                pointNum++;
                //递归
                backtracking(s,i+2,pointNum);
                //回溯
                pointNum--;
                //去除.分隔符
                s = s.substring(0,i+1)+s.substring(i+2);
            }else {
                break;
            }
        }
    }

    /**
     * 判断字符串s在左闭右闭区间[start, end]所组成的数字是否合法
     * @param s
     * @param start
     * @param end
     * @return
     */
    private Boolean isValid(String s, int start, int end) {
        if(start>end){
            return false;
        }
        //0开头的数字不合格
        if(s.charAt(start)=='0'&&start!=end){
            return false;
        }
        //非数字字符不合格
        for (int i=start;i<=end;i++){
            if(s.charAt(i)<'0'||s.charAt(i)>'9'){
                return false;
            }
        }
        //大于255的数字不合格
        int num = 0;
        for (int i=start;i<=end;i++){
            num = num*10+(s.charAt(i)-'0');
            if(num>255){
                return false;
            }
        }
        return true;
    }
}
```

### 78. 子集

给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。

```java
public class SubSet {

    List<List<Integer>> res = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();

    public List<List<Integer>> subsets(int[] nums){
        backtracking(nums,0);
        return res;
    }

    //1.确定回溯函数及参数
    private void backtracking(int[] nums,int startIndex){
        res.add(new LinkedList<>(path));
        //2.终止条件
        if(startIndex>nums.length-1){
            return;
        }
        //3.单层循环逻辑
        for (int i = startIndex; i < nums.length; i++) {
            //处理节点
            path.add(nums[i]);
            //递归
            backtracking(nums,i+1);
            //回溯
            path.removeLast();
        }
    }
}
```

### 90. 子集Ⅱ

给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。

```java
public class SubSet2 {

    List<List<Integer>> res = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();

    public List<List<Integer>> subsetsWithDup(int[] nums){
        //使用流不好分析时间复杂度，如果要分析复杂度最好用Arrays.sort(nums);
        nums = Arrays.stream(nums).sorted().toArray();
        backtracking(nums,0);
        return res;
    }

    //1.确定回溯函数及参数
    private void backtracking(int[] nums,int startIndex){
        res.add(new LinkedList<>(path));
        //2.终止条件
        if(startIndex>nums.length-1){
            return;
        }
        //3.单层循环逻辑
        //startIndex:记录每一层递归中集合nums中的元素从哪一个开始取
        for (int i = startIndex; i < nums.length; i++) {
            //下面if判断语句中的i>startIndex用得很巧妙，i>startIndex必能推出i-1>=0
            // 如果nums={1,2,2}，那么if(i-1>=0&&nums[i]==nums[i-1]){continue;}会求不到子集[1,2,2]
            if(i>startIndex&&nums[i]==nums[i-1]){
                continue;
            }
            //处理节点
            path.add(nums[i]);
            //递归
            backtracking(nums,i+1);
            //回溯
            path.removeLast();
        }
    }

    public static void main(String[] args) {
        SubSet2 subSet = new SubSet2();
        int[] array = {1, 2, 2};
        //array = Arrays.stream(array).sorted().toArray();
        //for (int i : array) {
        //    System.out.println(i);
        //}
        subSet.subsetsWithDup(array);
    }

}
```

### 491. 递增子序列

给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。

```java
public class FindSubsequences {
    List<List<Integer>> res = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();

    public List<List<Integer>> findSubsequences(int[] nums) {
        backtracking(nums,0);
        return res;
    }

    private void backtracking(int[] nums,int startIndex){
        if(path.size()>=2){
            res.add(new LinkedList<>(path));
        }
        //终止条件
        if(startIndex>nums.length-1){
            return;
        }
        //每一层创建一个map进行去重，例如nums=[1,2,1,1]，后面两个1不能在使用。同一父节点下的同层上使用过的元素就不能在使用了
        HashMap<Integer, Integer> map = new HashMap<>();
        //单层循环逻辑
        for(int i = startIndex;i<nums.length;i++){
            //避免回溯时加入重复的答案
            //if(i>startIndex&&nums[i]==nums[i-1]){
            //    continue;
            //}
            if(map.getOrDefault(nums[i],0)>=1){
                continue;
            }
            if(path.size()>=1&&nums[i]<path.peekLast()){
                continue;
            }
            //记录每一层中各元素出现的次数
            map.put(nums[i],map.getOrDefault(nums[i],0)+1);
            //处理节点
            path.add(nums[i]);
            //递归
            backtracking(nums,i+1);
            //回溯
            path.removeLast();
        }
    }
}
```

### 46. 全排列

给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

```java
public class Permute {
    List<List<Integer>> res = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();

    public List<List<Integer>> permute(int[] nums){
        //nums为空判断
        if(nums==null||nums.length==0){
            return res;
        }
        backtracking(nums);
        return res;
    }
    //确定回溯函数及参数
    private void backtracking(int[] nums){
        //终止条件
        if(path.size()== nums.length){
            res.add(new LinkedList<>(path));
            return;
        }

        //单层for循环逻辑
        for (int i = 0; i < nums.length; i++) {
            //处理节点
            if(path.contains(nums[i])){
                continue;
            }
            path.add(nums[i]);
            //递归
            backtracking(nums);
            //回溯
            path.removeLast();
        }
    }
}
```

### 47. 全排列Ⅱ

给定一个可包含重复数字的序列 nums ，按任意顺序返回所有不重复的全排列。

```java
public class PermuteUnique {

    List<List<Integer>> res = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    /**
     * 使用一个used数组进行去重
     */
    boolean[] used;
    /**
     * permute:排列
     * @param nums
     * @return
     */
    public List<List<Integer>> permuteUnique(int[] nums){
        //nums为空判断
        if(nums==null||nums.length==0){
            return res;
        }
        used = new boolean[nums.length];
        Arrays.sort(nums);
        backtracking(nums,used);
        return res;
    }

    //确定回溯函数及参数
    private void backtracking(int[] nums,boolean[] used){
        //终止条件
        if(path.size()== nums.length){
            res.add(new LinkedList<>(path));
            return;
        }
        //单层for循环逻辑
        for (int i = 0; i < nums.length; i++) {
            //处理节点
            if(i>0&&nums[i]==nums[i-1]&&used[i-1]==false){
                continue;
            }
            if(used[i]){
                continue;
            }
            path.add(nums[i]);
            used[i] = true;
            //递归
            backtracking(nums,used);
            //回溯
            path.removeLast();
            used[i] = false;
        }
    }
}
```

### 51. N皇后

按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。

```java
/**N皇后问题
 * @author yhli3
 * @ClassName SolveNQueens.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.回溯算法
 * @createTime 2022年05月30日 18:44:00
 */
public class SolveNQueens {

    //debug测试
    public static void main(String[] args) {
        SolveNQueens solveNQueens = new SolveNQueens();
        solveNQueens.solveNQueens(4);
    }

    List<List<String>> res = new ArrayList<>();

    public List<List<String>> solveNQueens(int n) {
        char[][] chessboard = new char[n][n];
        for (char[] c : chessboard) {
            Arrays.fill(c,'.');
        }
        backtracking(n,0,chessboard);
        return res;
    }

    /**
     * 确定回溯函数及参数
     * @param n
     * @param row
     * @param chessboard
     */
    public void backtracking(int n, int row, char[][] chessboard) {
        //终止条件:不要写成row==n-1了
        if(row==n){
            res.add(path(chessboard));
            return;
        }
        //单层for循环逻辑
        for (int col = 0; col < n; col++) {
            if(isValid(row,col,n,chessboard)){
                //处理节点
                chessboard[row][col]='Q';
                //递归
                backtracking(n,row+1,chessboard);
                //回溯
                chessboard[row][col]='.';
            }
        }
    }

    public List path(char[][] chessboard) {
        List<String> list = new ArrayList<>();
        for (char[] c : chessboard) {
            String s = new String(c);
            list.add(s);
        }
        return list;
    }

    /**
     * 判断皇后摆放的位置是否满足约束条件:1.不能同列；2.不能同一对角线；3.不能同行（递归每一行只选取一个元素，因此可以不用判断）
     * @param row
     * @param col
     * @param n
     * @param chessboard
     * @return
     */
    public boolean isValid(int row, int col, int n, char[][] chessboard) {
        int rowTemp = row;
        int colTemp = col;
        //同列判断
        for (int i = 0; i < row; i++) {
            if(chessboard[i][col]=='Q'){
                return false;
            }
        }

        //同一对角线判断(如何判断二维矩阵某一元素所在的45°和135°方向的元素一样)

        //45°对角线判断
        while(row-1>=0&&col+1<n){
            if(chessboard[row-1][col+1]=='Q'){
                return false;
            }
            row--;
            col++;
        }

        //135°对角线判断
        while (rowTemp-1>=0&&colTemp-1>=0){
            if(chessboard[rowTemp-1][colTemp-1]=='Q'){
                return false;
            }
            rowTemp--;
            colTemp--;
        }
        return true;
    }
}
```

## 贪心算法

### 455. 分发饼干

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

```java
public class FindContentChildren {
    /**
     * 贪心思想
     * 局部最优：尺寸大的饼干优先满足大胃口的孩子
     * @param g
     * @param s
     * @return
     */
    public int findContentChildren(int[] g,int[] s){
        //将数组s和g升序排列
        Arrays.sort(g);
        Arrays.sort(s);
        int index = s.length-1;
        int count = 0;
        for (int i = g.length-1; i >= 0; i--) {
            if(index>=0&&g[i]<=s[index]){
                index--;
                count++;
            }
        }
        return count;
    }
}
//解法二：
   /**
     * 贪心思想
     * 局部最优：尺寸小的饼干优先满足小胃口的孩子
     * @param g
     * @param s
     * @return
     */
    public static int findContentChildren(int[] g,int[] s){
        //将数组s和g升序排列
        Arrays.sort(g);
        Arrays.sort(s);
        int index = 0;
        int count = 0;
        for (int i = 0; i < s.length&&index<g.length; i++) {
            if(s[i]>=g[index]){
                count++;
                index++;
            }
        }
        return count;
    }
```

### 376. 摆动序列

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。

```java
/**局部最优：删除单调坡度上的处于中间的节点，则这个坡度有两个局部峰值
 * 整体最优：整个序列有多个局部峰值，从而达到最长摆动序列
 * @author yhli3
 * @ClassName WiggleMaxLength.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.贪心
 * @createTime 2022年03月26日 09:42:00
 */
public class WiggleMaxLength {
    public int wiggleMaxLength(int[] nums) {
        if(nums.length<=1){
            return nums.length;
        }
        //当前差值
        int curDiff = 0;
        //上一个差值
        int preDiff = 0;
        //count计算的是左边的峰值
        int count = 1;
        for (int i = 1; i < nums.length; i++) {
            curDiff = nums[i]-nums[i-1];
            if((curDiff>0&&preDiff<=0)||(curDiff<0&&preDiff>=0)){
                count++;
                preDiff = curDiff;
            }
        }
        return count;
    }
}
```

### 53. 最大子数组和（贪心解法）

给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。子数组是数组中的一个连续部分。

```java
/**最大子序列和
 * @author yhli3
 * @ClassName MaxSubArray.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.贪心
 * @createTime 2022年03月28日 11:24:00
 */
public class MaxSubArray {
    public int maxSubArray(int[] nums){
        if(nums.length==1){
            return nums[0];
        }
        int sum = Integer.MIN_VALUE;
        int count = 0;
        for (int i = 0; i < nums.length; i++) {
            count+=nums[i];
            sum = Math.max(sum,count);
            if(count<=0){
                count = 0;
            }
        }
        return sum;
    }
}
```

### 122. 买卖股票的最佳时机Ⅱ（贪心解法）

给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。返回 你能获得的最大利润。

```java
 /**
     * 局部最优：收集每天的正利润;全局最优：得到最大利润;关键:price[2]-price[0]=(price[2]-price[1])+(price[1]-price[0])
     * @param prices
     * @return
     */
    public int maxProfit(int[] prices){
        int res = 0;
        for (int i = 0; i < prices.length-1; i++) {
            res+=Math.max(prices[i+1]-prices[i],0);
        }
        return res;
    }
```

### 55. 跳跃游戏

给定一个非负整数数组nums ，你最初位于数组的第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。

```java
 /**
     * 每次更新最大覆盖范围
     * @param nums
     * @return
     */
    public boolean canJump(int[] nums){
        int cover = 0;
        for (int i = 0; i <=cover; i++) {
            cover = Math.max(cover,i+nums[i]);
            if(nums.length-1<=cover){
                return true;
            }
        }
        return false;
    }
```

### 45. 跳跃游戏Ⅱ

给你一个非负整数数组 nums ，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。假设你总是可以到达数组的最后一个位置。

```java
  public int jump(int[] nums){
        if (nums == null || nums.length == 0 || nums.length == 1) {
            return 0;
        }
        //记录跳跃的次数
        int count=0;
        //当前的覆盖最大区域
        int curDistance = 0;
        //最大的覆盖区域
        int maxDistance = 0;
        for (int i = 0; i < nums.length; i++) {
            //在可覆盖区域内更新最大的覆盖区域
            maxDistance = Math.max(maxDistance,i+nums[i]);
            //说明当前一步，再跳一步就到达了末尾
            if (maxDistance>=nums.length-1){
                count++;
                break;
            }
            //走到当前覆盖的最大区域时，更新下一步可达的最大区域
            if (i==curDistance){
                curDistance = maxDistance;
                count++;
            }
        }
        return count;
    }
```

### 1005. K次取反后最大化的数组和

给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。重复这个过程恰好 k 次。可以多次选择同一个下标 i 。以这种方式修改数组后，返回数组 可能的最大和 。

//方法一

```java
 public int largestSumAfterKNegations(int[] nums,int k){
        Arrays.sort(nums);
        int bound = 0;
        int res = 0;
        //找到排序后数组中正数和负数的分界线
        for (int i = 0; i < nums.length; i++) {
            if(nums[i]<0){
                bound++;
            }else {
                break;
            }
        }
        if(k<=bound){
            for(int i = 0;i<k;i++){
                nums[i] = -nums[i];
            }
            //for (int num : nums) {
            //    res+=num;
            //}
            //return res;
            return Arrays.stream(nums).sum();
        }
        //如果k-bound是偶数
        if((k-bound)%2==0){
            for(int i = 0;i<bound;i++){
                nums[i] = -nums[i];
            }
            //for (int num : nums) {
            //    res+=num;
            //}
            //return res;
            return Arrays.stream(nums).sum();
        }else {
            for(int i = 0;i<bound;i++){
                nums[i] = -nums[i];
            }
            if(bound< nums.length&&bound!=0&&nums[bound]<=nums[bound-1]){
                nums[bound] = -nums[bound];
            }else if (bound< nums.length&&bound!=0&&nums[bound]>nums[bound-1]) {
                nums[bound-1] = -nums[bound-1];
            }else if(bound==0){
                nums[bound] = -nums[bound];
            }else if(bound==nums.length){
                nums[bound-1] = -nums[bound-1];
            }
            //for (int num : nums) {
            //    res+=num;
            //}
            //return res;
            return Arrays.stream(nums).sum();
        }
    }
```

//方法二

```java
 //让数组nums按照绝对值从大到小排序
        nums = Arrays.stream(nums).boxed().sorted((c1,c2)->Math.abs(c2)-Math.abs(c1)).mapToInt(Integer::intValue).toArray();
        for (int i = 0; i < nums.length; i++) {
            //遇到负数进行翻转，且k减一
            if(nums[i]<0&&k>0){
                nums[i] = -nums[i];
                k--;
            }
        }
        //将最小的数进行翻转
        if(k%2==1) nums[nums.length-1] = -nums[nums.length-1];
        return Arrays.stream(nums).sum();
```

小结：面试写算法的时候最好不要用stream。

### 134. 加油站

在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。给定两个整数数组 gas 和 cost ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则保证它是唯一 的。

```java
    /**
     * gas数组所有元素之和如果小于cost数组所有元素之和，那么无论从那个加油站开始算一定不可能跑完一圈
     * @param gas
     * @param cost
     * @return
     */
    public int canCompleteCircuit(int[] gas, int[] cost){
        int curSurSum = 0;
        int allSurSum = 0;
        int index = 0;
        //从第一个加油站开始遍历
        for (int i = 0; i < gas.length; i++) {
            curSurSum+=gas[i]-cost[i];
            allSurSum+=gas[i]-cost[i];
            //curSurSum<0，不可能是当前加油站i
            if(curSurSum<0){
                //更新起始位置
                index = (i+1)% gas.length;
                curSurSum = 0;
            }
        }
        if(allSurSum<0){
            return -1;
        }
        return index;
    }
```

### 860. 柠檬水找零

在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。注意，一开始你手头没有任何零钱。给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。

```java
public boolean lemonadeChange(int[] bills){
        int five = 0;
        int ten = 0;
        int twenty = 0;
        for (int i = 0; i < bills.length; i++) {
            if(bills[i]==5){
                five++;
            }
            if(bills[i]==10){
                if(five<=0){
                    return false;
                }
                five--;
                ten++;
            }
            //贪心：如果顾客给的是20元，优先找给客户一张十元和一张五元，其次是三张五元
            if(bills[i]==20){
                if(five>0&&ten>0){
                    five--;
                    ten--;
                    twenty--;
                }else if(five>=3){
                    five-=3;
                }else {
                    return false;
                }
            }
        }
        return true;
    }
```

//更加优雅的代码

```java
//可以不用声明twenty这个变量
 public boolean lemonadeChange(int[] bills){
        int five = 0,ten = 0;
        for (int i = 0; i < bills.length; i++) {
            if(bills[i]==5) five++;
            if(bills[i]==10){
                if(five<=0) return false;
                five--;
                ten++;
            }
            //贪心：如果顾客给的是20元，优先找给客户一张十元和一张五元，其次是三张五元
            if(bills[i]==20){
                if(five>0&&ten>0){
                    five--;
                    ten--;
                }else if(five>=3){
                    five-=3;
                }else {
                    return false;
                }
            }
        }
        return true;
    }
```

### 406. 根据身高重建队列

假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面正好有 ki 个身高大于或等于 hi 的人。请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。

![根据身高重建队列-2022-05-10-14-17-58](https://images-1309978559.cos.ap-chengdu.myqcloud.com/blogimages/根据身高重建队列-2022-05-10-14-17-58.png)

```java
    public int[][] reconstructQueue(int[][] people){
        // 身高从大到小排（身高相同k小的站前面）
        Arrays.sort(people, (a, b) -> {
            if (a[0] == b[0]) return a[1] - b[1];
            return b[0] - a[0];
        });
        
        LinkedList<int[]> que = new LinkedList<>();
        //add(index,element)：在指定位置index处插入元素element，如果que中已经存在index,那么将已存在的index及其后面的元素往后移动（即索引加一）
        for (int[] p : people) {
            que.add(p[1],p);
        }

        return que.toArray(new int[people.length][]);
    }
```

### 452. 用最少数量的箭引爆气球

有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。

![用最少数量的箭引爆气球-2022-05-10-21-26-02](https://images-1309978559.cos.ap-chengdu.myqcloud.com/blogimages/用最少数量的箭引爆气球-2022-05-10-21-26-02.png)

```java
 /**
     * 局部最优：当气球出现重叠时一起射，所用弓箭最少；全局最优：全部射爆气球所用弓箭最少
     * @param points
     * @return
     */
    public static int findMinArrowShots(int[][] points){
        if (points.length == 0) return 0;
        //{{10, 16}, {2, 8}, {1, 6}, {7, 12}};排序后为{{1, 6},{2, 8},{7, 12},{10, 16}};
        Arrays.sort(points, (o1, o2) -> Integer.compare(o1[0], o2[0]));

        int count = 1;
        for (int i = 1; i < points.length; i++) {
            if (points[i][0] > points[i - 1][1]) {
                count++;
            } else {
                points[i][1] = Math.min(points[i][1],points[i - 1][1]);
            }
        }
        return count;
    }
```

### 435. 无重叠区间（难度较大）

给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。

```java
 public int eraseOverlapIntervals(int[][] intervals) {
        Arrays.sort(intervals, (a, b) -> {
            if (a[0] == a[0]) return a[1] - b[1];
            return a[0] - b[0];
        });

        int count = 0;
        int edge = Integer.MIN_VALUE;
        for (int i = 0; i < intervals.length; i++) {
            if (edge <= intervals[i][0]) {
                edge = intervals[i][1];
            } else {
                count++;
            }
        }

        return count;
    }
```

### 763. 划分字母区间

字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。

```java
   public static List<Integer> partitionLabels(String s){
        List<Integer> list = new ArrayList<>();
        //定义一个长度为26的数组，从第一个元素开始，每个位置的元素依次为a,b,c,d...
        int[] edge = new int[26];
        char[] chars = s.toCharArray();
        //统计字符串s中每个字符最后出现的位置，例如edge[0]==8表示字符串s中的字符a最后出现的位置在下标为8的地方
        for (int i = 0; i < chars.length; i++) {
            edge[chars[i]-'a'] = i;
        }
        int idx = 0;
        int last = 0;
        for (int i = 0; i < chars.length; i++) {
            idx = Math.max(idx,edge[chars[i]-'a']);
            if(idx==i){
                list.add(i-last+1);
                last = i+1;
            }
        }
        return list;
    }
```

### 56. 合并区间

以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。

```java
 public int[][] merge(int[][] intervals) {
        List<int[]> res = new LinkedList<>();
        //按照左边界进行排序
        Arrays.sort(intervals, (o1, o2) -> Integer.compare(o1[0], o2[0]));
        int start = intervals[0][0];
        for (int i = 1; i < intervals.length; i++) {
            if (intervals[i][0] > intervals[i - 1][1]) {
                res.add(new int[]{start, intervals[i - 1][1]});
                start = intervals[i][0];
            } else {
                intervals[i][1] = Math.max(intervals[i][1], intervals[i - 1][1]);
            }
        }
        res.add(new int[]{start, intervals[intervals.length - 1][1]});
        return res.toArray(new int[res.size()][]);
    }
```

### 738. 单调递增的数字

当且仅当每个相邻位数上的数字 x 和 y 满足 x <= y 时，我们称这个整数是单调递增的。给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增 。

```java
 /**
     *System.out.println(String.join("-","li","yue","hong"));//li-yue-hong
     * @param n
     * @return
     */
    public int monotoneIncreasingDigits(int n) {
        String s = String.valueOf(n);
        char[] chars = s.toCharArray();
        int start = s.length();
        for (int i = s.length()-2; i >= 0; i--) {
            if(chars[i]>chars[i+1]){
                /**
                 *  char[] chars = {'5'};
                 *  chars[0]--;
                 *  System.out.println(chars[0]);//4
                 */
                chars[i]--;
                start = i+1;
            }
        }
        for (int i = start; i < s.length(); i++) {
            chars[i] = '9';
        }
        return Integer.parseInt(String.valueOf(chars));
    }
```

### 714. 买卖股票的最佳时机含手续费

给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最大值。注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

![买卖股票的最佳时机含手续费-2022-05-17-21-30-30](https://images-1309978559.cos.ap-chengdu.myqcloud.com/blogimages/买卖股票的最佳时机含手续费-2022-05-17-21-30-30.png)

```java
//了解一下贪心的思想，一般还是用动规来做
 public int maxProfit(int[] prices,int fee){
        int buy = prices[0] + fee;
        int sum = 0;
        for (int p : prices) {
            if (p + fee < buy) {
                buy = p + fee;
            } else if (p > buy){
                sum += p - buy;
                buy = p;
            }
        }
        return sum;
    }
```

## 动态规划

### 509. 斐波那契数

斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n > 1 给你n ，请计算 F(n) 。

```java

/**斐波那契数
 * @author yhli3
 * @ClassName Fib.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年03月28日 14:54:00
 */
public class Fib {
    public int fib (int n){
        if(n<=1){
            return n;
        }
        //维护一个dp列表
        int[] dp = new int[n+1];
        //数据初始化
        dp[0] = 0;
        dp[1] = 1;
        //遍历求dp[n]的值
        for (int i = 2; i < n + 1; i++) {
            //状态转移方程
            dp[i] = dp[i-1]+dp[i-2];
        }
        return dp[n];
    }
}

```

### 70. 爬楼梯

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

```java
/**爬楼梯
 * @author yhli3
 * @ClassName ClimbStairs.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年03月28日 15:24:00
 */
public class ClimbStairs {
    public int climbStairs(int n){
        if(n<=2){
            return n;
        }
        //dp[i]代表到达第i个台阶有dp[i]种方法
        //状态转移方程：dp[i]=dp[i-1]+dp[i-2]
        int[] dp = new int[n+1];
        //dp列表初始化
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i < n + 1; i++) {
            dp[i] = dp[i-1]+dp[i-2];
        }
        return dp[n];
    }
}
```

### 741. 使用最小花费爬楼梯

给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。请你计算并返回达到楼梯顶部的最低花费。

```java
    public int minCostClimbingStairs(int[] cost) {
        //维护一个dp列表,dp[i]代表到达第i个阶梯所花费的最少费用
        //状态转移方程：dp[i] = min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2])
        int[] dp = new int[cost.length+1];
        //数据初始化
        dp[0] = 0;
        dp[1] = 0;
        for (int i = 2; i < dp.length; i++) {
            dp[i] = Math.min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]);
        }
        return dp[cost.length];
    }
```

### 62. 不同路径

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？

![不同路径-2022-05-09-20-52-43](https://images-1309978559.cos.ap-chengdu.myqcloud.com/blogimages/不同路径-2022-05-09-20-52-43.png)

```java
/**
 * @author yhli3
 * @ClassName UniquePaths.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年03月29日 09:22:00
 */
public class UniquePaths {
    public int uniquePaths(int m,int n){
        int[][] dp = new int[m][n];
        //状态转移方程：dp[i][j]=dp[i-1][j]+dp[i][j-1];
        for (int i = 0; i < n; i++) {
            dp[0][i] = 1;
        }
        for (int i = 0; i < m; i++) {
            dp[i][0] = 1;
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j]=dp[i-1][j]+dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
}
```

### 63. 不同的路径Ⅱ

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用 1 和 0 来表示。

![不同路径Ⅱ-2022-05-09-20-53-37](https://images-1309978559.cos.ap-chengdu.myqcloud.com/blogimages/不同路径Ⅱ-2022-05-09-20-53-37.png)

```java
public static int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int r = obstacleGrid.length;
        int c = obstacleGrid[0].length;
        //确定dp数组及其下标的含义
        int[][] dp = new int[r][c];

        //dp初始化
        for (int i = 0; i < r; i++) {
            if(obstacleGrid[i][0]==1){
                break;
            }
            dp[i][0] = 1;
        }

        for (int i = 0; i < c; i++) {
            if(obstacleGrid[0][i]==1){
                break;
            }
            dp[0][i] = 1;
        }

        for (int i = 1; i < r; i++) {
            for (int j = 1; j < c; j++) {
                if(obstacleGrid[i][j]==1){
                    continue;
                }
                //递推公式
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
         return dp[r-1][c-1];
}
```

### 343. 整数拆分

给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k >= 2 ），并使这些整数的乘积最大化。返回你可以获得的最大乘积 。

```java
/**
 * @author yhli3
 * @ClassName IntegerBreak.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年03月29日 15:02:00
 */
public class IntegerBreak {
    public int integerBreak(int n){
        int[] dp = new int[n + 1];
        dp[2] = 1;
        for (int i = 3; i <=n; i++) {
            for (int j = 1; j <=i-j; j++) {
                dp[i] = Math.max(dp[i],Math.max(j*(i-j),j*dp[i-j]));
            }
        }
        return dp[n];
    }
}
```

### 96. 不同的二叉搜索树

给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。

 ```java
public class NumTrees {
    public int numTrees(int n) {
        //初始化dp数组
        int[] dp = new int[n + 1];
        //初始化dp[0]和dp[1]
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            for (int j = 1; j <=i; j++) {
                //dp[i]=dp[i]+dp[j-1]*dp[i-j];定义int数组的时候，里面的元素默认初始值为0
                dp[i]+=dp[j-1]*dp[i-j];
            }
        }
        return dp[n];
    }
}
 ```

### 416. 分割等和子集

给你一个 只包含正整数的非空数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

```java
/**分割等和子集
 * @author yhli3
 * @ClassName CanPartition.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年04月05日 14:46:00
 */
public class CanPartition {
    /**
     * 背包的容量为sum/2(其中，sum为数组所有元素的和)
     * 物品、重量、价值都为nums[i]
     * @description 本质是一个01背包问题
     * @author yhli3
     * @param [nums]
     * @updateTime 2022/4/5 14:48
     * @return boolean
     */
    public boolean canPartition(int[] nums){
        //dp[j]代表容量为j的背包，可以凑成的最大子集和为dp[j]
        //dp[j]=Math.max(dp[j],dp[j-nums[i]]+nums[i])
        if(nums==null||nums.length==0){
            return false;
        }
        int totalSum = 0;
        for (int num : nums) {
            totalSum+=num;
        }
        if(totalSum%2!=0){
            return false;
        }
        int v = totalSum/2;
        int[] dp = new int[v + 1];
        //先遍历物品
        for (int i = 0; i < nums.length; i++) {
            //后遍历背包
            for (int j = v;j>=nums[i];j--){
                dp[j]=Math.max(dp[j],dp[j-nums[i]]+nums[i]);
            }
        }
        return dp[v] == v;
    }
    
}
```

### 1049. 最后一块石头的重量Ⅱ

有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：
如果 x == y，那么两块石头都会被完全粉碎；
如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。

//一维数组版本

```java
/**
 * 最后一块石头的重量Ⅱ
 *
 * @author yhli3
 * @ClassName LastStoneWeightII.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年04月07日 10:13:00
 */
public class LastStoneWeightII {
    public int lastStoneWeightII(int[] stones) {
        int sum = 0;
        for (int stone : stones) {
            sum+=stone;
        }
        int bagWeight = sum/2;
        int[] dp = new int[bagWeight+1];
        for (int i = 0; i < stones.length; i++) {
            for (int j = bagWeight; j >=stones[i]; j--) {
                dp[j] = Math.max(dp[j],dp[j-stones[i]]+stones[i]);
            }
        }
        return (sum-dp[bagWeight])-dp[bagWeight];
    }
}
```

//二维数组版本

```java
    /**
     * 二维数组版本
     * @param stones
     * @return
     */
    public int lastStoneWeightII(int[] stones) {
        int sum = 0;
        for (int stone : stones) {
            sum+=stone;
        }
        int bagWeight = sum/2;
        int[][] dp = new int[stones.length][bagWeight + 1];
        for(int j = stones[0];j<=bagWeight;j++){
            dp[0][j] = stones[0];
        }
        for (int i = 1; i < stones.length; i++) {
            for (int j = 1; j <= bagWeight; j++) {
                if(j>=stones[i]){
                    dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-stones[i]]+stones[i]);
                }else{
                    dp[i][j] = dp[i-1][j];
                }
            }
        }

        return (sum-dp[stones.length-1][bagWeight])-dp[stones.length-1][bagWeight];

    }
```

### 494. 目标和

给你一个整数数组 nums 和一个整数 target 。向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。

```java
public int findTargetSumWays(int[] nums, int target) {
        int sum = 0;
        for (int num : nums) {
            sum+=num;
        }
        if((sum+target)%2!=0||Math.abs(target)>sum){
            return 0;
        }
        int addition = (sum+target)/2;
        if(addition<0){
            addition = -addition;
        }
        //dp[j]表示装满容量为j的背包有dp[j]中方法
        int[] dp = new int[addition+1];
        dp[0] = 1;
        for (int i = 0; i < nums.length; i++) {
            for(int j =addition;j>=nums[i];j--){
                dp[j]+=dp[j-nums[i]];
                //logger.info(Arrays.toString(dp));
            }
        }
        return dp[addition];
    }
```

### 474. 一和零

给你一个二进制字符串数组 strs 和两个整数 m 和 n 。请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。

```java
/**474. 一和零
 * @author yhli3
 * @ClassName FindMaxForm.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年04月09日 19:28:00
 */
public class FindMaxForm {
    public int findMaxForm(String[] strs,int m,int n){
        //背包有两个维度
        //dp[i][j]表示最多有i个0，j个1的背包（字符串数组）的最大子集的长度
        int[][] dp = new int[m + 1][n + 1];
        int oneNum;
        int zeroNum;
        //01背包先遍历物品，即数组中的元素
        for (String str : strs) {
            oneNum = 0;
            zeroNum = 0;
            for (char c : str.toCharArray()) {
                if(c == '0'){
                    zeroNum++;
                }else{
                    oneNum++;
                }
            }
            //遍历背包
            for (int i = m; i >=zeroNum; i--) {
                for (int j = n; j >=oneNum; j--) {
                    dp[i][j] = Math.max(dp[i][j],dp[i-zeroNum][j-oneNum]+1);
                }
            }
        }
        return dp[m][n];
    }
}
```

### 518. 零钱兑换Ⅱ

给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。假设每一种面额的硬币有无限个。 题目数据保证结果符合 32 位带符号整数。

```java
/**
 * 完全背包：求填满背包的方法数
 * @author yhli3
 * @ClassName ChangeII.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年04月10日 16:09:00
 */
public class ChangeII {

    private static Logger logger = LoggerFactory.getLogger(ChangeII.class);

    public static int change(int amount,int[] coins){
         //dp[j] = Math.max(dp[j],dp[j-coins[i]]+1)
         int[] dp = new int[amount + 1];
         //初始化
         dp[0] = 1;
         //先遍历物品
         for (int i = 0; i < coins.length; i++) {
             //在遍历背包，因为是完全背包，因此需要正向遍历
             for(int j =coins[i];j<=amount;j++){
                 //求装满背包有多少种方法的递推公式
                 dp[j] += dp[j - coins[i]];
                 logger.info(Arrays.toString(dp));
             }
         }
         return dp[amount];
    }

    public static void main(String[] args) {
        int[] coins = {1, 2, 5};
        int amount = 5;
        change(amount,coins);
    }

}
```

### 377. 组合总和Ⅳ

给你一个由不同整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。题目数据保证答案符合 32 位整数范围。

```java
/**求装满背包有多少种装法，如果有顺序要求，就先遍历背包，在遍历物品
 * @author yhli3
 * @ClassName CombinationSum4.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年04月12日 10:20:00
 */
public class CombinationSum4 {

    private static Logger logger = LoggerFactory.getLogger(CombinationSum4.class);

    public static int combinationSum4(int[] nums, int target){
        int[] dp = new int[target + 1];
        dp[0] = 1;
        //先遍历背包
        for(int j = 0;j<=target;j++){
            //在遍历物品
            for (int i = 0; i < nums.length; i++) {
                if(j>=nums[i]){
                    dp[j]+=dp[j-nums[i]];
                    logger.info(Arrays.toString(dp));
                }
            }
        }
        return dp[target];
    }

    public static void main(String[] args) {
        int[] nums = {1, 2, 3};
        int target = 4;
        combinationSum4(nums,target);
    }

}
```

### 70. 爬楼梯（进阶版）

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

```java
/**可以看成是一个完全背包问题
 * @author yhli3
 * @ClassName ClimbStairsByBag.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年04月13日 10:54:00
 */
public class ClimbStairsByBag {

    public int climbStairs(int n){
        //台阶就是物品
        int[] weight = {1, 2};
        //楼顶相当于背包
        int[] dp = new int[n + 1];
        //初始化（关键）
        dp[0] = 1;
        //先遍历背包
        for(int j = 0;j<=n;j++){
            //在遍历物品
            for (int i = 0; i < weight.length; i++) {
                if(j>=weight[i]){
                    dp[j]+=dp[j-weight[i]];
                }
            }
        }
        return dp[n];
    }

}
```

### 322. 零钱兑换

给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。你可以认为每种硬币的数量是无限的。

```java
/**
 * @author yhli3
 * @ClassName CoinChange.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年04月13日 11:24:00
 */
public class CoinChange {
    public int coinChange(int[] coins, int amount) {
        if(amount==0){
            return 0;
        }
        //dp[j] = Math.min(dp[j-coins[i]]+1,dp[j])
        int[] dp = new int[amount+1];
        //初始化
        dp[0] = 0;
        for(int i =1;i<dp.length;i++){
            dp[i] = Integer.MAX_VALUE;
        }
        //先遍历物品
        for(int i =0;i<coins.length;i++){
            //后遍历背包
            for(int j = 0;j<=amount;j++){
                //Integer.MAX_VALUE==2147483647
                //Integer.MIN_VALUE==-2147483648
                //Integer.MAX_VALUE+1 == -2147483648
                if(j>=coins[i]&&dp[j-coins[i]]!=Integer.MAX_VALUE){
                    dp[j] = Math.min(dp[j-coins[i]]+1,dp[j]);
                }
            }
        }

        return dp[amount]==Integer.MAX_VALUE?-1:dp[amount];

    }
}
```

### 279. 完全平方数

给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

```java

/**279.完全平方数
 * @author yhli3
 * @ClassName NumSquares.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年04月14日 15:18:00
 */
public class NumSquares {

    private static Logger logger = LoggerFactory.getLogger(NumSquares.class);

    public static int numSquares(int n){
        //dp[j]代表凑满容量为j的背包，所需要最少的完全平方数的个数
        //递推公式：dp[j] = Math.min(dp[j],dp[j-i*i]+1)
        int[] dp = new int[n + 1];
        //初始化
        dp[0] = 0;
        for (int i = 1; i < dp.length; i++) {
            dp[i] = Integer.MAX_VALUE;
        }
        //先遍历物品
        for (int i = 1; i <= n; i++) {
            //后遍历背包
            for(int j = i*i;j<=n;j++){
                if(dp[j-i*i]!=Integer.MAX_VALUE){
                    dp[j] = Math.min(dp[j],dp[j-i*i]+1);
                    logger.info(Arrays.toString(dp));
                }
            }
        }
        return dp[n];
    }

    public static void main(String[] args) {
        int a = 12;
        numSquares(a);
    }

}
```

### 139. 单词拆分

给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

```java
public class WordBreak {

    private static Logger logger = LoggerFactory.getLogger(WordBreak.class);

    public static boolean wordBreak(String s, List<String> wordDict) {
        //dp[j]:长度为j的字符串是否可由字典中的元素拼接而成

        //递推公式:if(dp[j]==true&&wordDict.contains(s.substring(j,i)))，推出dp[i]==true
        //对递推公式进行翻译：如果字符串s中的前0到j-1个字符可以由字典拼接而成，后j到i-1个字符也可以由字典拼接而成，那么s中的前i个字符可以由字典拼接而成，即dp[i]=true;

        boolean[] dp = new boolean[s.length() + 1];
        dp[0] = true;
//        //先背包
//        for (int j = 1; j <= s.length(); j++) {
//            //在物品
//            for (int i = 0; i <= j; i++) {
//                if (wordDict.contains(s.substring(i,j)) && dp[i]) {
//                    dp[j] = true;
//                    logger.info(Arrays.toString(dp));
//                }
//            }
//        }
        //先物品
        for (int i = 0; i <s.length(); i++) {
            //在背包
            for(int j = 1;j< dp.length;j++){
                if (j>=i && wordDict.contains(s.substring(i,j)) && dp[i]) {
                    dp[j] = true;
                    logger.info(Arrays.toString(dp));
                }
            }
        }
        return dp[s.length()];
    }

    public static void main(String[] args) {
        String s = "leetcode";
        List<String> list = new ArrayList<String>(){{
           add("leet");
           add("code");
        }};
        wordBreak(s,list);
    }
}
```

### 198. 打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

```java
 public int rob(int[] nums){
        //dp[j]：打劫前j家（包括j）房屋(房屋从0开始编号)的最大收益为dp[j]

        //dp[j] = Math.max(dp[j-2]+nums[j],dp[j-1])

        //初始化：dp[0] = nums[0],dp[1] = Math.max(nums[0],nums[1])

        //遍历顺序：从前往后遍历

        //举例推导dp数组

        if(nums==null||nums.length==0){
            return 0;
        }

        if(nums.length==1){
            return nums[0];
        }

        int[] dp = new int[nums.length];

        dp[0] = nums[0];

        dp[1] = Math.max(nums[0],nums[1]);

        for (int j = 2; j < nums.length; j++) {
            dp[j] = Math.max(dp[j-2]+nums[j],dp[j-1]);
        }

        return dp[nums.length-1];

    }
```

### 213. 打家劫舍Ⅱ

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。

```java
 public static int rob(int[] nums){
        //dp[j]：打劫前j家（包括j）房屋(房屋从0开始编号)的最大收益为dp[j]

        //dp[j] = Math.max(dp[j-2]+nums[j],dp[j-1])

        //初始化：dp[0] = nums[0],dp[1] = Math.max(nums[0],nums[1])

        //遍历顺序：从前往后遍历

        //举例推导dp数组

        if(nums==null||nums.length==0){
            return 0;
        }

        if(nums.length==1){
            return nums[0];
        }

        int[] dp = new int[nums.length];

        int[] dp1 = new int[nums.length];

        //打劫第一家
        dp[0] = nums[0];
        dp[1] = nums[0];
        for (int j = 2; j < nums.length-1; j++) {
            dp[j] = Math.max(dp[j-2]+nums[j],dp[j-1]);
        }
        //不打劫第一家
        dp1[0] = 0;
        dp1[1] = nums[1];
        for (int j = 2; j < nums.length; j++) {
            dp1[j] = Math.max(dp1[j-2]+nums[j],dp1[j-1]);
        }
        return Math.max(dp[nums.length-2],dp1[nums.length-1]);
    }

```

### 337. 打家劫舍Ⅲ

小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。

```java
    private static Logger logger = LoggerFactory.getLogger(Rob3.class);

    // 3.状态标记递归
    // 执行用时：0 ms , 在所有 Java 提交中击败了 100% 的用户
    // 不偷：Max(左孩子不偷，左孩子偷) + Max(又孩子不偷，右孩子偷)
    // root[0] = Math.max(rob(root.left)[0], rob(root.left)[1]) +
    // Math.max(rob(root.right)[0], rob(root.right)[1])
    // 偷：左孩子不偷+ 右孩子不偷 + 当前节点偷
    // root[1] = rob(root.left)[0] + rob(root.right)[0] + root.val;

    public static int rob3(TreeNode root) {
        int[] res = robAction1(root);
        return Math.max(res[0], res[1]);
    }

    static int[] robAction1(TreeNode root) {
        logger.info("当前节点的值：{}",root==null?null:root.val);
        //1
        int res[] = new int[2];
        //2
        if (root == null) return res;
        //3
        int[] left = robAction1(root.left);
        logger.info("left数组：{}",Arrays.toString(left));
        //4
        int[] right = robAction1(root.right);
        logger.info("right数组：{}",Arrays.toString(right));
        //5
        res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
        //6
        res[1] = root.val + left[0] + right[0];
        //7
        logger.info("res数组：{}",Arrays.toString(res));
        return res;
    }

    public static void main(String[] args) {
        Integer[] array = {3,2,3,null,3,null,1};
        rob3(TreeUtil.createTree(array));
    }

```

### 121. 买卖股票的最佳时机

给定一个数组 prices ，它的第i个元素prices[i] 表示一支给定股票第 i 天的价格。你只能选择某一天买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

```java
public class MaxProfit {

    public int maxProfit(int[] prices){
        //默认初始时口袋中的钱为0
        //dp[i][0]:第i天持有股票，口袋中的钱为dp[i][0]
        //dp[i][1]:第i天不持有股票，口袋中的钱为dp[i][1]
        //dp[i][0] = Math.max(-prices[i],dp[i-1][0])
        //dp[i][1] = Math.max(prices[i]+dp[i-1][0],dp[i-1][1])

        if(prices == null || prices.length==0){
            return 0;
        }

        int length = prices.length;

        int[][] dp = new int[length][2];

        dp[0][0] = -prices[0];
        dp[0][1] = 0;

        for (int i = 1; i < length; i++) {
            dp[i][0] = Math.max(-prices[i],dp[i-1][0]);
            dp[i][1] = Math.max(prices[i]+dp[i-1][0],dp[i-1][1]);
        }
        return dp[length-1][1];
    }
    
}
```

### 122. 买卖股票的最佳时机Ⅱ

给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。在每一天，你可以决定是否购买和/或出售股票。你在任何时候最多只能持有一股股票。你也可以先购买，然后在 同一天 出售。返回你能获得的最大利润 。

```java
/**
 * @author yhli3
 * @ClassName MaxProfit2.java
 * @packageName yhli.work.doalgorithmwithidea.代码随想录.动态规划
 * @createTime 2022年04月22日 19:33:00
 */
public class MaxProfit2 {

    public int maxProfit(int[] prices){
        int n = prices.length;
        int[][] dp = new int[n][2];

        //dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]-prices[i])
        //dp[i][1] = Math.max(dp[i-1][1],prices[i]+dp[i-1][0])

        dp[0][0] = -prices[0];
        dp[0][1] = 0;

        for (int i = 1; i < n; i++) {
            dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]-prices[i]);
            dp[i][1] = Math.max(dp[i-1][1],prices[i]+dp[i-1][0]);
        }

        return dp[n-1][1];

    }

}

```

### 123. 买卖股票的最佳时机Ⅲ

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。**你最多可以完成两笔交易**。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

```java
 public int maxProfit(int[] prices){
        if(prices==null||prices.length==0){
            return 0;
        }
        /**
         * 初始时口袋中的钱为0
         * dp[i][j]:第i+1天，第j种状态时口袋中的现金为dp[i][j]
         * 五种状态：
         * 0：没有操作，1：第一次买入，2：第一次卖出，3：第二次买入，4：第二次卖出
         */
        int[][] dp = new int[prices.length][5];

        //初始化
        dp[0][1] = -prices[0];
        dp[0][2] = 0;
        dp[0][3] = -prices[0];
        dp[0][4] = 0;

        /**
         * 初始时现金为0，那么买入股票的时候，dp[i][1]或dp[i][3]一定为负数，计算利润的时候就不难理解为什么会出现prices[i]+dp[i-1][1]和prices[i]+dp[i-1][3]
         */
        for(int i = 1;i<prices.length;i++){
            /**
             * dp[i][1]可以分为两种情况：1.前一天（i-1）已经买入；2. 第i天才买入
             */
            dp[i][1] = Math.max(dp[i-1][1],-prices[i]);
            dp[i][2] = Math.max(dp[i-1][2],prices[i]+dp[i-1][1]);
            dp[i][3] = Math.max(dp[i-1][3],dp[i-1][2]-prices[i]);
            dp[i][4] = Math.max(dp[i-1][4],prices[i]+dp[i-1][3]);
        }
        return dp[prices.length-1][4];
    }
```

### 188. 买卖股票的最佳时机Ⅳ

给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

```java
    public int maxProfit(int k,int[] prices){
        if(prices==null||prices.length==0){
            return 0;
        }

        /**
         * 初始时口袋中的钱为0
         * dp[i][j]:第i+1天，第j种状态时口袋中的现金为dp[i][j]
         * 2k+1种状态：
         * 0：没有操作，1：第一次买入，2：第一次卖出，3：第二次买入，4：第二次卖出......
         */
        int[][] dp = new int[prices.length][2*k+1];

        //初始化


        for (int i = 1; i < 2*k; i+=2) {
            dp[0][i] = -prices[0];
        }

        /**
         * 初始时现金为0，那么买入股票的时候，dp[i][1]或dp[i][3]一定为负数，计算利润的时候就不难理解为什么会出现prices[i]+dp[i-1][1]和prices[i]+dp[i-1][3]
         * dp[i][1]可以分为两种情况：1.前一天（i-1）已经买入；2. 第i天才买入
         */
        for(int i = 1;i<prices.length;i++){
            for (int j =1;j<=2*k;j+=2){
                dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-1]-prices[i]);
                dp[i][j+1] = Math.max(dp[i-1][j+1],prices[i]+dp[i-1][j]);
            }
            //dp[i][1] = Math.max(dp[i-1][1],-prices[i]);
            //dp[i][2] = Math.max(dp[i-1][2],prices[i]+dp[i-1][1]);
            //dp[i][3] = Math.max(dp[i-1][3],dp[i-1][2]-prices[i]);
            //dp[i][4] = Math.max(dp[i-1][4],prices[i]+dp[i-1][3]);
        }
        return dp[prices.length-1][2*k];
    }
```

### 309. 最佳买卖股票时机含冷冻期

给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。​设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）：卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）

```java
    /**
     * 分为四种状态：
     * 0. 买入股票状态（今天买入或者之前就买入了）
     * 1. 两天前就卖出股票了，度过了冷冻期，一直没有操作，今天保持卖出股票状态
     * 2. 今天卖出股票
     * 3. 冷冻期状态
     * @param prices
     * @return
     */
    public int maxProfit(int[] prices){

        if(prices==null||prices.length<2){
            return 0;
        }

        int[][] dp = new int[prices.length][4];
        dp[0][0] = -prices[0];
        for (int i = 1; i < prices.length; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], Math.max(dp[i - 1][3], dp[i - 1][1]) - prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][3]);
            dp[i][2] = dp[i - 1][0] + prices[i];
            dp[i][3] = dp[i - 1][2];
        }
        
        return Math.max(dp[prices.length-1][3],Math.max(dp[prices.length-1][1], dp[prices.length-1][2]));

    }
```

### 714. 买卖股票的最佳时机含手续费

给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最大值。注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

```java
public int maxProfit(int[] prices, int fee){

        //默认初始时口袋中的钱为0
        //dp[i][0]:第i天持有股票状态，口袋中的钱为dp[i][0]
        //dp[i][1]:第i天不持有股票状态，口袋中的钱为dp[i][1]

        //dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]-prices[i])
        //dp[i][1] = Math.max(dp[i-1][1],prices[i]+dp[i-1][0])
        int n = prices.length;
        int[][] dp = new int[n][2];

        //初始化
        dp[0][0] = -prices[0];
        dp[0][1] = 0;

        for (int i = 1; i < n; i++) {
            dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]-prices[i]);
            //和买卖股票的最佳时机Ⅱ的区别是多减了一个fee
            dp[i][1] = Math.max(dp[i-1][1],prices[i]+dp[i-1][0]-fee);
        }

        return dp[n-1][1];
    }
```

### 300. 最长递增子序列

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

```java
public class LengthOfLIS {

    private static Logger logger = LoggerFactory.getLogger(LengthOfLIS.class);

    public static int lengthOfLIS(int[] nums) {
        //dp[i]：nums中，0到i这个子区间内最长上升子序列的长度为dp[i]
        int[] dp = new int[nums.length];
        Arrays.fill(dp, 1);
        for (int i = 0; i < dp.length; i++) {
            for (int j = 0; j < i; j++) {
                //递推公式
                if (nums[i] > nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                    logger.info(Arrays.toString(dp));
                }
            }
        }
        int res = 0;
        for (int i = 0; i < dp.length; i++) {
            res = Math.max(res, dp[i]);
        }
        return res;
    }

    //测试
    public static void main(String[] args) {
        int[] array = {10, 9, 2, 5, 3, 7, 101, 18};
        lengthOfLIS(array);
    }

}

```

### 674. 最长连续递增序列

给定一个未经排序的整数数组，找到最长且连续递增的子序列，并返回该序列的长度。连续递增的子序列可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。

```java
    public int findLengthOfLCIS(int[] nums){
        //dp[i]：数组中以i结尾(起点不一定是i==0的位置)的子数组的最长连续递增子序列的长度为dp[i]
        //递推公式：if(nums[i+1]>nums[i]) dp[i+1] = dp[i] + 1;
        int[] dp = new int[nums.length];
        Arrays.fill(dp,1);
        for (int i = 0; i < nums.length-1; i++) {
            if(nums[i+1]>nums[i]){
                dp[i+1] = dp[i] + 1;
            }
        }
        int res = 0;
        for (int i : dp) {
            res = Math.max(i,res);
        }
        return res;
    }
```

### 718. 最长重复子数组

给两个整数数组 nums1 和 nums2 ，返回两个数组中公共的 、长度最长的子数组的长度 。

```java
public int findLength(int[] nums1, int[] nums2) {
        //dp[i][j]：以i-1结尾的子数组a和以j-1结尾的子数组b的最长公共后缀子数组的长度为dp[i][j]
        int result = 0;
        int[][] dp = new int[nums1.length + 1][nums2.length + 1];

        for (int i = 1; i < nums1.length + 1; i++) {
            for (int j = 1; j < nums2.length + 1; j++) {
                if (nums1[i - 1] == nums2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                    result = Math.max(result, dp[i][j]);
                }
            }
        }
        return result;
    }
```

### 1143. 最长公共子序列

给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。如果不存在公共子序列 ，返回 0 。一个字符串的子序列是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的公共子序列是这两个字符串所共同拥有的子序列。


```java
 /**
     * 子序列可以是不连续的，子数组或子字符串需要是连续的
     * @param text1
     * @param text2
     * @return
     */
    public int longestCommonSubsequence(String text1,String text2){
        //dp[i][j]:以i-1结尾的前缀字串A和以j-1结尾的前缀字串B的最长公共子序列长度为dp[i][j]
        int[][] dp = new int[text1.length() + 1][text2.length() + 1];
        for (int i = 1; i <= text1.length(); i++) {
            for (int j = 1; j <= text2.length(); j++) {
                if(text1.charAt(i-1)==text2.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1] + 1;
                }else {
                    //ace和bc的最长公共子序列的长度为取ac和bc、ace和b中的最长公共子序列的长度的最大值
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[text1.length()][text2.length()];
    }
```

### 1035. 不相交的线

在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足：nums1[i] == nums2[j]；且绘制的直线不与任何其他连线（非水平线）相交。请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。以这种方法绘制线条，并返回可以绘制的最大连线数。

```java

    /**
     * 本质和求两个字符串的最长公共子序列一样
     * @param nums1
     * @param nums2
     * @return
     */
    public int maxUncrossedLines(int[] nums1, int[] nums2){
        //dp[i][j]:以i-1结尾的前缀子数组A和以j-1结尾的前缀子数组B的最长公共子序列长度为dp[i][j]
        int[][] dp = new int[nums1.length + 1][nums2.length + 1];
        for (int i = 1; i <= nums1.length; i++) {
            for (int j = 1; j <= nums2.length; j++) {
                if(nums1[i-1]==nums2[j-1]){
                    dp[i][j] = dp[i-1][j-1] + 1;
                }else {
                    //ace和bc的最长公共子序列的长度为取ac和bc、ace和b中的最长公共子序列的长度的最大值
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[nums1.length][nums2.length];
    }
```

### 53. 最大子数组和（动规解法）

给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
子数组 是数组中的一个连续部分。

```java
public static int maxSubArray(int[] nums) {
        //dp[i]表示以nums[i]结尾的连续子数组的最大和（是要包括nums[i]在内的连续子数组）
        //dp[i] = Math.max(nums[i],dp[i-1]+nums[i])
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        for (int i = 1; i < nums.length; i++) {
            dp[i] = Math.max(nums[i],dp[i-1]+nums[i]);
            // logger.info(Arrays.toString(dp));
        }
        //res初始化为nums[0]避免出现传进来的数组只有一个元素，例如{-1}
        int res = nums[0];
        for (int i : dp) {
            res = Math.max(res,i);
        }
        return res;
    }
```

### 392. 判断子序列

给定字符串 s 和 t ，判断 s 是否为 t 的子序列。字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。
进阶：如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？

```java
//本质就是求两个字符串的最长公共子序列的长度，如果最长公共子序列的长度和字符串s的长度相等，那么返回true
  public boolean isSubsequence(String s, String t) {
        //dp[i][j]:以下标i-1结尾的前缀字串A和以下标j-1结尾的前缀字串B的最长公共子序列的长度为dp[i][j]
        //如果把dp[i][j]定义为以下标i结尾的前缀字串A和以下标j结尾的前缀字串B的最长公共子序列的长度为dp[i][j]，那么对dp[0][j]和dp[i][0]的初始化很麻烦
        int[][] dp = new int[s.length()+1][t.length()+1];
        int res = 0;
        for(int i = 1;i<=s.length();i++){
            for(int j = 1;j<=t.length();j++){
                if(s.charAt(i-1)==t.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1] + 1;
                }else{
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                }
                res = res>dp[i][j]?res:dp[i][j];
            }
        }
        if(res==s.length()){
            return true;
        }
        return false;
    }
```

### 583. 两个字符串的删除操作

给定两个单词 word1 和 word2 ，返回使得 word1 和  word2 相同所需的最小步数。每步可以删除任意一个字符串中的一个字符。

```java
    /**
     * 本质与求两个字符串的最长公共子序列的长度类似
     * @param word1
     * @param word2
     * @return
     */
    public int minDistance(String word1, String word2){
        int[][] dp = new int[word1.length() + 1][word2.length()+1];
        for (int i = 1; i <= word1.length(); i++) {
            for (int j = 1; j <= word2.length(); j++) {
                if(word1.charAt(i-1)==word2.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1]+1;
                }else{
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        //word1的长度=word1非公共子序列的长度+word1和word2公共子序列的长度
        //word2的长度=word2非公共子序列的长度+word1和word2公共子序列的长度
        //最小步数=word1非公共子序列的长度+word2非公共子序列的长度
        return word1.length()+word2.length()-2*dp[word1.length()][word2.length()];
    }
```

### 647. 回文字串

给你一个字符串 s ，请你统计并返回这个字符串中回文子串的数目。回文字符串是正着读和倒过来读一样的字符串。子字符串 是字符串中的由连续字符组成的一个序列。具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

```java
 public int countSubstrings(String s) {
        //dp[i][j]:字符串s中区间[i,j]的字串如果是一个回文串，那么dp[i][j]为true,否则为false
        boolean[][] dp = new boolean[s.length()][s.length()];
        int res = 0;
        for (int j = 0; j < s.length(); j++) {
            for(int i =0;i<=j;i++){
                if(s.charAt(i)==s.charAt(j)){
                    if(j-i<=1){
                        res++;
                        dp[i][j] = true;
                    }else if(dp[i+1][j-1]){//例如s="cabcca"，s[1]==s[5]，如果bcc为回文串，那么abcca必为回文串
                        res++;
                        dp[i][j] = true;
                    }
                }
            }
        }
        return res;
    }
```

### 516. 最长回文子序列

给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

```java
  public int longestPalindromeSubseq(String s){
        //dp[i][j]:字符串s中位于区间[i,j]的字串的最长回文子序列的长度为dp[i][j]
        int l = s.length();
        int[][] dp = new int[l+1][l+1];
        for (int i = l-1; i >= 0; i--) {
            //只有一个字符，最长回文子序列的长度为1
            dp[i][i] = 1;
            for(int j=i+1;j<l;j++){
                if(s.charAt(i)==s.charAt(j)){
                    dp[i][j] = dp[i+1][j-1] + 2;
                }else{
                    dp[i][j] = Math.max(dp[i+1][j],dp[i][j-1]);
                }
            }
        }
        return dp[0][l-1];
    }
```

## 单调栈

### 739. 每日温度

给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指在第 i 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。

```java
    /**单调栈的本质：空间换时间（与两层for循环的暴力解法相比）
     * 何时用单调栈：通常是一维数组，需要寻找某个元素右边或者左边第一个比它大或者小的元素的位置；
     * 单调栈中存放什么：存放的是数组元素的下标；
     * 从栈顶到栈底使用递增还是递减顺序：根据不同的题目具体分析，本题采用元素递增序列
     * @param temperatures
     * @return
     */
    public int[] dailyTemperatures(int[] temperatures){
        int[] res = new int[temperatures.length];
        Stack<Integer> stack = new Stack<>();
        stack.push(0);
        for (int i = 1; i < temperatures.length; i++) {
            if(temperatures[i]<=temperatures[stack.peek()]){
                stack.push(i);
            }else{
                while (!stack.empty()&&temperatures[i]>temperatures[stack.peek()]){
                    res[stack.peek()] = i-stack.peek();
                    stack.pop();
                }
                stack.push(i);
            }
        }
        return res;
    }
```

### 496. 下一个更大元素Ⅰ

nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。对于每个 0 <= i < nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的下一个更大元素 。

```java
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        int[] res = new int[nums1.length];
        //初始化res中的元素为-1
        Arrays.fill(res,-1);
        // int[] array = new int[nums2.length];
        //新建哈希表，k存nums1中的元素，v存的是元素的下标
        Map<Integer,Integer> map = new HashMap<>();
        for(int i =0;i<nums1.length;i++){
            map.put(nums1[i],i);
        }
        Stack<Integer> stack = new Stack<>();
        stack.push(0);
        for(int i = 1;i<nums2.length;i++){
            if(nums2[i]<nums2[stack.peek()]){
                stack.push(i);
            }else{
                while(!stack.empty()&&nums2[i]>nums2[stack.peek()]){
                    if(map.containsKey(nums2[stack.peek()])){
                        res[map.get(nums2[stack.peek()])] = nums2[i];
                    }
                    // array[i] = i-stack.pop();
                    stack.pop();
                }
                stack.push(i);
            }
        }
        return res;
    }
```

### 503. 下一个更大的元素 Ⅱ

给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素 。数字 x 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1 。

```java
 /**
     * 将两个数组拼接到一起，然后使用单调栈求解
     * @param nums
     * @return
     */
    public int[] nextGreaterElements(int[] nums){
        int[] array = new int[nums.length * 2];
        int[] res = new int[nums.length*2];
        //快速初始化数组
        Arrays.fill(res,-1);
        for (int i = 0; i < nums.length; i++) {
            array[i] = nums[i];
            array[i+ nums.length] = nums[i];
        }
        Stack<Integer> stack = new Stack<>();
        stack.push(0);
        for (int i = 1; i < array.length; i++) {
            if(array[i]<=array[stack.peek()]){
                stack.push(i);
            }else{
                while(!stack.empty()&&array[i]>array[stack.peek()]){
                    res[stack.peek()] = array[i];
                    stack.pop();
                }
                stack.push(i);
            }
        }
        return Arrays.copyOfRange(res,0,res.length/2);
    }
```
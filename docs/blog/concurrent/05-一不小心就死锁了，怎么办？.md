---
toc: true
title: 05-一不小心就死锁了，怎么办？
date: 2022-2-15
tags: [《Java并发编程实战》]
categories: 
- Concurrent
---

- 使用Account.class作为互斥锁，锁的范围太大了，虽然不会有并发问题，但是会导致所有账户的转账操作都是串行的，性能较差

- 使用细粒度锁可以提高并行度和性能，但是如果使用不当也会导致死锁

- 死锁：一组互相竞争资源的线程因互相等待，导致持续阻塞的现象
<!--more-->
- 并发程序出现死锁，很多时候只能靠重启解决。因此，解决死锁问题的最好办法是规避死锁

- 死锁发生的条件（以下四个条件需同时满足）：
  - 互斥：即共享资源A和B只能被一个线程占用
  - 占有且等待：线程T1已经取得共享资源A，在等待共享资源B的时候，不释放共享资源A
  - 不可抢占：其他线程不能强行抢占线程T1占有的资源
  - 循环等待：线程T1等待线程T2占有的资源，线程T2等待线程T1占有的资源

- 只要破坏死锁发生条件的其中一个就可以规避死锁了（注意：互斥这个条件不能被破坏，因为加锁的目的就是为了互斥）

- 破坏死锁发生的条件：
  - 破坏占有且等待这一条件：可以一次性申请所有的资源
  - 破坏不可抢占这一条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源
  - 破坏循环等待这一条件：可以按序申请资源来预防，即对资源进行编号，申请的时候可以先申请资源编号小的，然后在申请资源编号大的

- 选择破坏死锁条件的方案的时候需要评估操作成本，从中选择一个成本最低的方案









































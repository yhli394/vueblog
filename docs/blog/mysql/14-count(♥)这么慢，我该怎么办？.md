---
toc: true
title: 14-count(♥)这么慢，我该怎么办？
date: 2022-5-28
tags: [MySQL实战45讲]
categories:
 - MySQL
---

## count(*)的实现方式

不同的存储引擎中，count(*)的实现方式不一样：

- MyISAM:

> MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高；

- InnoDB:

> InnoDB 引擎执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。

## 为什么InnoDB不和MyISAM一样也把表的总行数存起来？

> 这是因为即使是在同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的。

作者举了一个例子来进行解释：

![20220528110801-2022-05-28-11-08-02](https://images-1309978559.cos.ap-chengdu.myqcloud.com/blogimages/20220528110801-2022-05-28-11-08-02.png)

## 用缓存系统保存计数

> 将计数保存在缓存系统中的方式，还不只是丢失更新(Redis持久化的时候出现异常重启，宕机等情况会导致数据更新丢失)的问题。即使 Redis 正常工作，这个值还是逻辑上不精确的。

作者解释了逻辑上不清楚是如何定义的，并且举了两个例子进行说明：

> 我们是这么定义不精确的：
> 一种是，查到的 100 行结果里面有最新插入记录，而 Redis 的计数里还没加 1；
> 另一种是，查到的 100 行结果里没有最新插入的记录，而 Redis 的计数里已经加了 1。

查到的 100 行结果里面有最新插入记录，而 Redis 的计数里还没加 1:
![20220528113046-2022-05-28-11-30-47](https://images-1309978559.cos.ap-chengdu.myqcloud.com/blogimages/20220528113046-2022-05-28-11-30-47.png)

查到的 100 行结果里没有最新插入的记录，而 Redis 的计数里已经加了 1：

![20220528113154-2022-05-28-11-31-54](https://images-1309978559.cos.ap-chengdu.myqcloud.com/blogimages/20220528113154-2022-05-28-11-31-54.png)

## 使用数据库保存计数

在MySQL数据库中新建一张表t来保存计数可以解决使用缓存计数带来的两大问题：

- 数据丢失（InnoDB 是支持崩溃恢复不丢数据的）

- 计数不精确(利用事务的特性解决)

作者举了以下一个例子进行说明：

![20220528113702-2022-05-28-11-37-02](https://images-1309978559.cos.ap-chengdu.myqcloud.com/blogimages/20220528113702-2022-05-28-11-37-02.png)
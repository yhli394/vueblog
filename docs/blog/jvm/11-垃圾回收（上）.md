---
toc: true
title: 11-垃圾回收（上）
date: 2022-2-11
tags: [《深入拆解Java虚拟机》] 
categories:
- JVM
---



## 垃圾回收

1. 垃圾回收指的是将已经分配出去的，但不在使用的内存回收回来，以便能够再次分配
2. Java虚拟机语境下，垃圾指的是死亡的对象所占据的堆空间

## 引用计数法（reference counting）

1. 原理：在每一个对象身上放一个引用计数器，用以统计指向该对象的引用个数，当引用计数器中的个数为0，说明此对象已经死亡，可以回收
2. 缺点：
   - 存储引用计数器带来了额外的空间开销
   - 频繁的计数更新（增减）操作
   - 无法处理循环引用对象（a,b两个对象相互引用，无其它引用指向a和b，虽然引用计数器不为0，但是a,b实际已死亡）
<!--more-->
## GC Roots

> A garbage collection root is an object that is accessible from outside the heap

1. GC Roots一般包括以下四种：
    - Java方法栈帧中的局部变量
    - 已加载类的静态变量
    - JNI(java native interface) handles
    - 已启动且未停止的Java线程

## 可达性分析算法

1. 本质：将一系列GC Roots作为初始的存活对象合集（live set），然后从该合集出发，探索所有能够被该集合引用的对象，并将其加入到该集合中，此过程称为标记（mark）。最终未被探索到的对象已死亡，可以回收
2. Java虚拟机的主流垃圾回收器采用的是可达性分析算法
3. 可以解决引用计数法不能解决的循环引用问题
4. 误报：可达性分析**误认为**某个对象是**可达（对象未死亡）**，实际**不可达（已死亡）**。
5. 漏报：可达性分析**没有发现**某个对象**可达（对象未死亡）**。

## 传统的垃圾回收算法

1. 传统的垃圾回收算法采用Stop-the-world的形式回收垃圾，即当Java虚拟机收到Stop-the-world请求的时候，会等待所有的线程都到达安全点（safepoint），才会允许请求Stop-the-world的线程进行垃圾回收工作
2. 垃圾回收暂停时间(GC pause):从非垃圾回收线程停止工作到垃圾回收线程完成垃圾回收这一段时间
3. 安全点：并非让其他线程停下来，而是找到一个稳定的执行状态。在这个执行状态下，Java虚拟机的堆栈不会发生变化，这样垃圾回收器便能够“安全”地执行可达性分析

## 垃圾回收的三种方式

清除(sweep)、压缩(compact)、复制(copy)

### 清除

1. 原理：即把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表（free list）之中，当需要新建对象时，内存管理模块会从该空闲列表中寻找空闲内存，分配给新建的对象
2. 缺点：
   - 造成内存碎片
   - 分配效率较低

### 压缩

1. 原理：把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间
2. 优点：能够解决内存碎片化的问题
3. 缺点：压缩算法的性能开销

### 复制

1. 原理：将内存区域分为两等分，分别用from和to指针来维护，并且只是用from指针指向的内存区域来分配内存，当发生垃圾回收时，把存活的对象复制到to指针指向的内存区域中，交换from指针和to指针的内容
2. 优点：能够解决内存碎片化的问题
3. 缺点：堆空间的使用效率低下

## 参考文献

1. https://help.eclipse.org/latest/index.jsp?topic=%2Forg.eclipse.mat.ui.help%2Fconcepts%2Fgcroots.html





























